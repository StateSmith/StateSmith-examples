// Autogenerated with StateSmith 0.11.2-alpha+4a4e30018e9a371124530fa96cf2ba3322b80459.
// Algorithm: Balanced1. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

#include "SolarUiSm.h"
#include "display.h"

#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(SolarUiSm* sm, SolarUiSm_Func desired_state_exit_handler);

static void ROOT_enter(SolarUiSm* sm);

static void ROOT_exit(SolarUiSm* sm);

static void BATTERY_STATS_enter(SolarUiSm* sm);

static void BATTERY_STATS_exit(SolarUiSm* sm);

static void BATTERY_STATS_left(SolarUiSm* sm);

static void BATTERY_STATS_1_enter(SolarUiSm* sm);

static void BATTERY_STATS_1_exit(SolarUiSm* sm);

static void BATTERY_STATS_1_down(SolarUiSm* sm);

static void BATTERY_STATS_2_enter(SolarUiSm* sm);

static void BATTERY_STATS_2_exit(SolarUiSm* sm);

static void BATTERY_STATS_2_down(SolarUiSm* sm);

static void BATTERY_STATS_2_up(SolarUiSm* sm);

static void BATTERY_STATS_3_enter(SolarUiSm* sm);

static void BATTERY_STATS_3_exit(SolarUiSm* sm);

static void BATTERY_STATS_3_up(SolarUiSm* sm);

static void HOME_enter(SolarUiSm* sm);

static void HOME_exit(SolarUiSm* sm);

static void HOME_right(SolarUiSm* sm);

static void MAIN_MENU_enter(SolarUiSm* sm);

static void MAIN_MENU_exit(SolarUiSm* sm);

static void MAIN_MENU_left(SolarUiSm* sm);

static void MAIN_MENU_1_enter(SolarUiSm* sm);

static void MAIN_MENU_1_exit(SolarUiSm* sm);

static void MAIN_MENU_1_down(SolarUiSm* sm);

static void MAIN_MENU_1_right(SolarUiSm* sm);

static void MAIN_MENU_2_enter(SolarUiSm* sm);

static void MAIN_MENU_2_exit(SolarUiSm* sm);

static void MAIN_MENU_2_right(SolarUiSm* sm);

static void MAIN_MENU_2_up(SolarUiSm* sm);

static void SOLAR_STATS_enter(SolarUiSm* sm);

static void SOLAR_STATS_exit(SolarUiSm* sm);

static void SOLAR_STATS_left(SolarUiSm* sm);

static void SOLAR_STATS_1_enter(SolarUiSm* sm);

static void SOLAR_STATS_1_exit(SolarUiSm* sm);

static void SOLAR_STATS_1_down(SolarUiSm* sm);

static void SOLAR_STATS_2_enter(SolarUiSm* sm);

static void SOLAR_STATS_2_exit(SolarUiSm* sm);

static void SOLAR_STATS_2_down(SolarUiSm* sm);

static void SOLAR_STATS_2_up(SolarUiSm* sm);

static void SOLAR_STATS_3_enter(SolarUiSm* sm);

static void SOLAR_STATS_3_exit(SolarUiSm* sm);

static void SOLAR_STATS_3_up(SolarUiSm* sm);

static void SPLASH_enter(SolarUiSm* sm);

static void SPLASH_exit(SolarUiSm* sm);

static void SPLASH_right(SolarUiSm* sm);


// State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
void SolarUiSm_ctor(SolarUiSm* sm)
{
    memset(sm, 0, sizeof(*sm));
}

// Starts the state machine. Must be called before dispatching events. Not thread safe.
void SolarUiSm_start(SolarUiSm* sm)
{
    ROOT_enter(sm);
    // ROOT behavior
    // uml: TransitionTo(ROOT.<InitialState>)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
        // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<InitialState> behavior
        // uml: TransitionTo(SPLASH)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `SPLASH`.
            SPLASH_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = SolarUiSm_StateId_SPLASH;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for ROOT.<InitialState>
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
void SolarUiSm_dispatch_event(SolarUiSm* sm, SolarUiSm_EventId event_id)
{
    SolarUiSm_Func behavior_func = sm->current_event_handlers[event_id];
    
    while (behavior_func != NULL)
    {
        sm->ancestor_event_handler = NULL;
        behavior_func(sm);
        behavior_func = sm->ancestor_event_handler;
    }
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(SolarUiSm* sm, SolarUiSm_Func desired_state_exit_handler)
{
    while (sm->current_state_exit_handler != desired_state_exit_handler)
    {
        sm->current_state_exit_handler(sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(SolarUiSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = ROOT_exit;
}

static void ROOT_exit(SolarUiSm* sm)
{
    // State machine root is a special case. It cannot be exited. Mark as unused.
    (void)sm;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state BATTERY_STATS
////////////////////////////////////////////////////////////////////////////////

static void BATTERY_STATS_enter(SolarUiSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = BATTERY_STATS_exit;
    sm->current_event_handlers[SolarUiSm_EventId_LEFT] = BATTERY_STATS_left;
}

static void BATTERY_STATS_exit(SolarUiSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[SolarUiSm_EventId_LEFT] = NULL;  // no ancestor listens to this event
}

static void BATTERY_STATS_left(SolarUiSm* sm)
{
    // No ancestor state handles `left` event.
    
    // BATTERY_STATS behavior
    // uml: LEFT TransitionTo(MAIN_MENU_2)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MAIN_MENU_2`.
        MAIN_MENU_enter(sm);
        MAIN_MENU_2_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = SolarUiSm_StateId_MAIN_MENU_2;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for BATTERY_STATS
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state BATTERY_STATS_1
////////////////////////////////////////////////////////////////////////////////

static void BATTERY_STATS_1_enter(SolarUiSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = BATTERY_STATS_1_exit;
    sm->current_event_handlers[SolarUiSm_EventId_DOWN] = BATTERY_STATS_1_down;
    
    // BATTERY_STATS_1 behavior
    // uml: enter / { show_battery_stats1(); }
    {
        // Step 1: execute action `show_battery_stats1();`
        show_battery_stats1();
    } // end of behavior for BATTERY_STATS_1
}

static void BATTERY_STATS_1_exit(SolarUiSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = BATTERY_STATS_exit;
    sm->current_event_handlers[SolarUiSm_EventId_DOWN] = NULL;  // no ancestor listens to this event
}

static void BATTERY_STATS_1_down(SolarUiSm* sm)
{
    // No ancestor state handles `down` event.
    
    // BATTERY_STATS_1 behavior
    // uml: DOWN TransitionTo(BATTERY_STATS_2)
    {
        // Step 1: Exit states until we reach `BATTERY_STATS` state (Least Common Ancestor for transition).
        BATTERY_STATS_1_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `BATTERY_STATS_2`.
        BATTERY_STATS_2_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = SolarUiSm_StateId_BATTERY_STATS_2;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for BATTERY_STATS_1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state BATTERY_STATS_2
////////////////////////////////////////////////////////////////////////////////

static void BATTERY_STATS_2_enter(SolarUiSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = BATTERY_STATS_2_exit;
    sm->current_event_handlers[SolarUiSm_EventId_DOWN] = BATTERY_STATS_2_down;
    sm->current_event_handlers[SolarUiSm_EventId_UP] = BATTERY_STATS_2_up;
    
    // BATTERY_STATS_2 behavior
    // uml: enter / { show_battery_stats2(); }
    {
        // Step 1: execute action `show_battery_stats2();`
        show_battery_stats2();
    } // end of behavior for BATTERY_STATS_2
}

static void BATTERY_STATS_2_exit(SolarUiSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = BATTERY_STATS_exit;
    sm->current_event_handlers[SolarUiSm_EventId_DOWN] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[SolarUiSm_EventId_UP] = NULL;  // no ancestor listens to this event
}

static void BATTERY_STATS_2_down(SolarUiSm* sm)
{
    // No ancestor state handles `down` event.
    
    // BATTERY_STATS_2 behavior
    // uml: DOWN TransitionTo(BATTERY_STATS_3)
    {
        // Step 1: Exit states until we reach `BATTERY_STATS` state (Least Common Ancestor for transition).
        BATTERY_STATS_2_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `BATTERY_STATS_3`.
        BATTERY_STATS_3_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = SolarUiSm_StateId_BATTERY_STATS_3;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for BATTERY_STATS_2
}

static void BATTERY_STATS_2_up(SolarUiSm* sm)
{
    // No ancestor state handles `up` event.
    
    // BATTERY_STATS_2 behavior
    // uml: UP TransitionTo(BATTERY_STATS_1)
    {
        // Step 1: Exit states until we reach `BATTERY_STATS` state (Least Common Ancestor for transition).
        BATTERY_STATS_2_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `BATTERY_STATS_1`.
        BATTERY_STATS_1_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = SolarUiSm_StateId_BATTERY_STATS_1;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for BATTERY_STATS_2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state BATTERY_STATS_3
////////////////////////////////////////////////////////////////////////////////

static void BATTERY_STATS_3_enter(SolarUiSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = BATTERY_STATS_3_exit;
    sm->current_event_handlers[SolarUiSm_EventId_UP] = BATTERY_STATS_3_up;
    
    // BATTERY_STATS_3 behavior
    // uml: enter / { show_battery_stats3(); }
    {
        // Step 1: execute action `show_battery_stats3();`
        show_battery_stats3();
    } // end of behavior for BATTERY_STATS_3
}

static void BATTERY_STATS_3_exit(SolarUiSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = BATTERY_STATS_exit;
    sm->current_event_handlers[SolarUiSm_EventId_UP] = NULL;  // no ancestor listens to this event
}

static void BATTERY_STATS_3_up(SolarUiSm* sm)
{
    // No ancestor state handles `up` event.
    
    // BATTERY_STATS_3 behavior
    // uml: UP TransitionTo(BATTERY_STATS_2)
    {
        // Step 1: Exit states until we reach `BATTERY_STATS` state (Least Common Ancestor for transition).
        BATTERY_STATS_3_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `BATTERY_STATS_2`.
        BATTERY_STATS_2_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = SolarUiSm_StateId_BATTERY_STATS_2;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for BATTERY_STATS_3
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state HOME
////////////////////////////////////////////////////////////////////////////////

static void HOME_enter(SolarUiSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = HOME_exit;
    sm->current_event_handlers[SolarUiSm_EventId_RIGHT] = HOME_right;
    
    // HOME behavior
    // uml: enter / { show_home(); }
    {
        // Step 1: execute action `show_home();`
        show_home();
    } // end of behavior for HOME
}

static void HOME_exit(SolarUiSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[SolarUiSm_EventId_RIGHT] = NULL;  // no ancestor listens to this event
}

static void HOME_right(SolarUiSm* sm)
{
    // No ancestor state handles `right` event.
    
    // HOME behavior
    // uml: RIGHT TransitionTo(MAIN_MENU)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        HOME_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MAIN_MENU`.
        MAIN_MENU_enter(sm);
        
        // MAIN_MENU.<InitialState> behavior
        // uml: TransitionTo(MAIN_MENU_1)
        {
            // Step 1: Exit states until we reach `MAIN_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `MAIN_MENU_1`.
            MAIN_MENU_1_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = SolarUiSm_StateId_MAIN_MENU_1;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for MAIN_MENU.<InitialState>
    } // end of behavior for HOME
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MAIN_MENU
////////////////////////////////////////////////////////////////////////////////

static void MAIN_MENU_enter(SolarUiSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MAIN_MENU_exit;
    sm->current_event_handlers[SolarUiSm_EventId_LEFT] = MAIN_MENU_left;
}

static void MAIN_MENU_exit(SolarUiSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[SolarUiSm_EventId_LEFT] = NULL;  // no ancestor listens to this event
}

static void MAIN_MENU_left(SolarUiSm* sm)
{
    // No ancestor state handles `left` event.
    
    // MAIN_MENU behavior
    // uml: LEFT TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = SolarUiSm_StateId_HOME;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MAIN_MENU
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MAIN_MENU_1
////////////////////////////////////////////////////////////////////////////////

static void MAIN_MENU_1_enter(SolarUiSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MAIN_MENU_1_exit;
    sm->current_event_handlers[SolarUiSm_EventId_DOWN] = MAIN_MENU_1_down;
    sm->current_event_handlers[SolarUiSm_EventId_RIGHT] = MAIN_MENU_1_right;
    
    // MAIN_MENU_1 behavior
    // uml: enter / { show_main_menu1(); }
    {
        // Step 1: execute action `show_main_menu1();`
        show_main_menu1();
    } // end of behavior for MAIN_MENU_1
}

static void MAIN_MENU_1_exit(SolarUiSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MAIN_MENU_exit;
    sm->current_event_handlers[SolarUiSm_EventId_DOWN] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[SolarUiSm_EventId_RIGHT] = NULL;  // no ancestor listens to this event
}

static void MAIN_MENU_1_down(SolarUiSm* sm)
{
    // No ancestor state handles `down` event.
    
    // MAIN_MENU_1 behavior
    // uml: DOWN TransitionTo(MAIN_MENU_2)
    {
        // Step 1: Exit states until we reach `MAIN_MENU` state (Least Common Ancestor for transition).
        MAIN_MENU_1_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MAIN_MENU_2`.
        MAIN_MENU_2_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = SolarUiSm_StateId_MAIN_MENU_2;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MAIN_MENU_1
}

static void MAIN_MENU_1_right(SolarUiSm* sm)
{
    // No ancestor state handles `right` event.
    
    // MAIN_MENU_1 behavior
    // uml: RIGHT TransitionTo(SOLAR_STATS)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `SOLAR_STATS`.
        SOLAR_STATS_enter(sm);
        
        // SOLAR_STATS.<InitialState> behavior
        // uml: TransitionTo(SOLAR_STATS_1)
        {
            // Step 1: Exit states until we reach `SOLAR_STATS` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `SOLAR_STATS_1`.
            SOLAR_STATS_1_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = SolarUiSm_StateId_SOLAR_STATS_1;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for SOLAR_STATS.<InitialState>
    } // end of behavior for MAIN_MENU_1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MAIN_MENU_2
////////////////////////////////////////////////////////////////////////////////

static void MAIN_MENU_2_enter(SolarUiSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MAIN_MENU_2_exit;
    sm->current_event_handlers[SolarUiSm_EventId_RIGHT] = MAIN_MENU_2_right;
    sm->current_event_handlers[SolarUiSm_EventId_UP] = MAIN_MENU_2_up;
    
    // MAIN_MENU_2 behavior
    // uml: enter / { show_main_menu2(); }
    {
        // Step 1: execute action `show_main_menu2();`
        show_main_menu2();
    } // end of behavior for MAIN_MENU_2
}

static void MAIN_MENU_2_exit(SolarUiSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MAIN_MENU_exit;
    sm->current_event_handlers[SolarUiSm_EventId_RIGHT] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[SolarUiSm_EventId_UP] = NULL;  // no ancestor listens to this event
}

static void MAIN_MENU_2_right(SolarUiSm* sm)
{
    // No ancestor state handles `right` event.
    
    // MAIN_MENU_2 behavior
    // uml: RIGHT TransitionTo(BATTERY_STATS)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `BATTERY_STATS`.
        BATTERY_STATS_enter(sm);
        
        // BATTERY_STATS.<InitialState> behavior
        // uml: TransitionTo(BATTERY_STATS_1)
        {
            // Step 1: Exit states until we reach `BATTERY_STATS` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `BATTERY_STATS_1`.
            BATTERY_STATS_1_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = SolarUiSm_StateId_BATTERY_STATS_1;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for BATTERY_STATS.<InitialState>
    } // end of behavior for MAIN_MENU_2
}

static void MAIN_MENU_2_up(SolarUiSm* sm)
{
    // No ancestor state handles `up` event.
    
    // MAIN_MENU_2 behavior
    // uml: UP TransitionTo(MAIN_MENU_1)
    {
        // Step 1: Exit states until we reach `MAIN_MENU` state (Least Common Ancestor for transition).
        MAIN_MENU_2_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MAIN_MENU_1`.
        MAIN_MENU_1_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = SolarUiSm_StateId_MAIN_MENU_1;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MAIN_MENU_2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SOLAR_STATS
////////////////////////////////////////////////////////////////////////////////

static void SOLAR_STATS_enter(SolarUiSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = SOLAR_STATS_exit;
    sm->current_event_handlers[SolarUiSm_EventId_LEFT] = SOLAR_STATS_left;
}

static void SOLAR_STATS_exit(SolarUiSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[SolarUiSm_EventId_LEFT] = NULL;  // no ancestor listens to this event
}

static void SOLAR_STATS_left(SolarUiSm* sm)
{
    // No ancestor state handles `left` event.
    
    // SOLAR_STATS behavior
    // uml: LEFT TransitionTo(MAIN_MENU_1)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MAIN_MENU_1`.
        MAIN_MENU_enter(sm);
        MAIN_MENU_1_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = SolarUiSm_StateId_MAIN_MENU_1;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for SOLAR_STATS
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SOLAR_STATS_1
////////////////////////////////////////////////////////////////////////////////

static void SOLAR_STATS_1_enter(SolarUiSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = SOLAR_STATS_1_exit;
    sm->current_event_handlers[SolarUiSm_EventId_DOWN] = SOLAR_STATS_1_down;
    
    // SOLAR_STATS_1 behavior
    // uml: enter / { show_solar_stats1(); }
    {
        // Step 1: execute action `show_solar_stats1();`
        show_solar_stats1();
    } // end of behavior for SOLAR_STATS_1
}

static void SOLAR_STATS_1_exit(SolarUiSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = SOLAR_STATS_exit;
    sm->current_event_handlers[SolarUiSm_EventId_DOWN] = NULL;  // no ancestor listens to this event
}

static void SOLAR_STATS_1_down(SolarUiSm* sm)
{
    // No ancestor state handles `down` event.
    
    // SOLAR_STATS_1 behavior
    // uml: DOWN TransitionTo(SOLAR_STATS_2)
    {
        // Step 1: Exit states until we reach `SOLAR_STATS` state (Least Common Ancestor for transition).
        SOLAR_STATS_1_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `SOLAR_STATS_2`.
        SOLAR_STATS_2_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = SolarUiSm_StateId_SOLAR_STATS_2;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for SOLAR_STATS_1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SOLAR_STATS_2
////////////////////////////////////////////////////////////////////////////////

static void SOLAR_STATS_2_enter(SolarUiSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = SOLAR_STATS_2_exit;
    sm->current_event_handlers[SolarUiSm_EventId_DOWN] = SOLAR_STATS_2_down;
    sm->current_event_handlers[SolarUiSm_EventId_UP] = SOLAR_STATS_2_up;
    
    // SOLAR_STATS_2 behavior
    // uml: enter / { show_solar_stats2(); }
    {
        // Step 1: execute action `show_solar_stats2();`
        show_solar_stats2();
    } // end of behavior for SOLAR_STATS_2
}

static void SOLAR_STATS_2_exit(SolarUiSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = SOLAR_STATS_exit;
    sm->current_event_handlers[SolarUiSm_EventId_DOWN] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[SolarUiSm_EventId_UP] = NULL;  // no ancestor listens to this event
}

static void SOLAR_STATS_2_down(SolarUiSm* sm)
{
    // No ancestor state handles `down` event.
    
    // SOLAR_STATS_2 behavior
    // uml: DOWN TransitionTo(SOLAR_STATS_3)
    {
        // Step 1: Exit states until we reach `SOLAR_STATS` state (Least Common Ancestor for transition).
        SOLAR_STATS_2_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `SOLAR_STATS_3`.
        SOLAR_STATS_3_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = SolarUiSm_StateId_SOLAR_STATS_3;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for SOLAR_STATS_2
}

static void SOLAR_STATS_2_up(SolarUiSm* sm)
{
    // No ancestor state handles `up` event.
    
    // SOLAR_STATS_2 behavior
    // uml: UP TransitionTo(SOLAR_STATS_1)
    {
        // Step 1: Exit states until we reach `SOLAR_STATS` state (Least Common Ancestor for transition).
        SOLAR_STATS_2_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `SOLAR_STATS_1`.
        SOLAR_STATS_1_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = SolarUiSm_StateId_SOLAR_STATS_1;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for SOLAR_STATS_2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SOLAR_STATS_3
////////////////////////////////////////////////////////////////////////////////

static void SOLAR_STATS_3_enter(SolarUiSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = SOLAR_STATS_3_exit;
    sm->current_event_handlers[SolarUiSm_EventId_UP] = SOLAR_STATS_3_up;
    
    // SOLAR_STATS_3 behavior
    // uml: enter / { show_solar_stats3(); }
    {
        // Step 1: execute action `show_solar_stats3();`
        show_solar_stats3();
    } // end of behavior for SOLAR_STATS_3
}

static void SOLAR_STATS_3_exit(SolarUiSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = SOLAR_STATS_exit;
    sm->current_event_handlers[SolarUiSm_EventId_UP] = NULL;  // no ancestor listens to this event
}

static void SOLAR_STATS_3_up(SolarUiSm* sm)
{
    // No ancestor state handles `up` event.
    
    // SOLAR_STATS_3 behavior
    // uml: UP TransitionTo(SOLAR_STATS_2)
    {
        // Step 1: Exit states until we reach `SOLAR_STATS` state (Least Common Ancestor for transition).
        SOLAR_STATS_3_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `SOLAR_STATS_2`.
        SOLAR_STATS_2_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = SolarUiSm_StateId_SOLAR_STATS_2;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for SOLAR_STATS_3
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SPLASH
////////////////////////////////////////////////////////////////////////////////

static void SPLASH_enter(SolarUiSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = SPLASH_exit;
    sm->current_event_handlers[SolarUiSm_EventId_RIGHT] = SPLASH_right;
    
    // SPLASH behavior
    // uml: enter / { show_splash(); }
    {
        // Step 1: execute action `show_splash();`
        show_splash();
    } // end of behavior for SPLASH
}

static void SPLASH_exit(SolarUiSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[SolarUiSm_EventId_RIGHT] = NULL;  // no ancestor listens to this event
}

static void SPLASH_right(SolarUiSm* sm)
{
    // No ancestor state handles `right` event.
    
    // SPLASH behavior
    // uml: RIGHT TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        SPLASH_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = SolarUiSm_StateId_HOME;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for SPLASH
}

// Thread safe.
char const * SolarUiSm_state_id_to_string(SolarUiSm_StateId id)
{
    switch (id)
    {
        case SolarUiSm_StateId_ROOT: return "ROOT";
        case SolarUiSm_StateId_BATTERY_STATS: return "BATTERY_STATS";
        case SolarUiSm_StateId_BATTERY_STATS_1: return "BATTERY_STATS_1";
        case SolarUiSm_StateId_BATTERY_STATS_2: return "BATTERY_STATS_2";
        case SolarUiSm_StateId_BATTERY_STATS_3: return "BATTERY_STATS_3";
        case SolarUiSm_StateId_HOME: return "HOME";
        case SolarUiSm_StateId_MAIN_MENU: return "MAIN_MENU";
        case SolarUiSm_StateId_MAIN_MENU_1: return "MAIN_MENU_1";
        case SolarUiSm_StateId_MAIN_MENU_2: return "MAIN_MENU_2";
        case SolarUiSm_StateId_SOLAR_STATS: return "SOLAR_STATS";
        case SolarUiSm_StateId_SOLAR_STATS_1: return "SOLAR_STATS_1";
        case SolarUiSm_StateId_SOLAR_STATS_2: return "SOLAR_STATS_2";
        case SolarUiSm_StateId_SOLAR_STATS_3: return "SOLAR_STATS_3";
        case SolarUiSm_StateId_SPLASH: return "SPLASH";
        default: return "?";
    }
}

// Thread safe.
char const * SolarUiSm_event_id_to_string(SolarUiSm_EventId id)
{
    switch (id)
    {
        case SolarUiSm_EventId_DOWN: return "DOWN";
        case SolarUiSm_EventId_LEFT: return "LEFT";
        case SolarUiSm_EventId_RIGHT: return "RIGHT";
        case SolarUiSm_EventId_UP: return "UP";
        default: return "?";
    }
}
