# Autogenerated with StateSmith 0.17.5+57dc3b48c7efef521ed074679928caf1480daae8.
# Algorithm: Balanced2. See https:#github.com/StateSmith/StateSmith/wiki/Algorithms

import enum
from LightBulb import LightBulb

# Generated state machine
class LightSm():
    class EventId(enum.Enum):
        TOGGLE = 0
    
    
    class StateId(enum.Enum):
        ROOT = 0
        OFF = 1
        ON = 2
    
    # State machine variables. Can be used for inputs, outputs, user variables...
    class Vars():
        def __init__(self):
            self.bulb = LightBulb()
            pass
    
    # State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
    def __init__(self, *args, **kwargs):
        # Used internally by state machine. Feel free to inspect, but don't modify.
        self.stateId = None
        
        # Variables. Can be used for inputs, outputs, user variables...
        self.vars = self.Vars()
    
    # Starts the state machine. Must be called before dispatching events. Not thread safe.
    def start(self):
        self._ROOT_enter()
        # ROOT behavior
        # uml: TransitionTo(ROOT.<InitialState>)
        if True:
            # Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            # Step 2: Transition action: ``.
            
            # Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
            # ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
            
            # ROOT.<InitialState> behavior
            # uml: TransitionTo(OFF)
            if True:
                # Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                # Step 2: Transition action: ``.
                
                # Step 3: Enter/move towards transition target `OFF`.
                self._OFF_enter()
                
                # Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return
            # end of behavior for ROOT.<InitialState>
        # end of behavior for ROOT
    
    
    # Dispatches an event to the state machine. Not thread safe.
    # Note! This function assumes that the `eventId` parameter is valid.
    def dispatchEvent(self, eventId):
        
        match self.stateId:
            # STATE: LightSm
            case LightSm.StateId.ROOT:
                pass
            
            # STATE: OFF
            case LightSm.StateId.OFF:
                self._OFF_toggle() 
            
            # STATE: ON
            case LightSm.StateId.ON:
                self._ON_toggle() 
        
    
    
    # This function is used when StateSmith doesn't know what the active leaf state is at
    # compile time due to sub states or when multiple states need to be exited.
    def _exitUpToStateHandler(self, desiredState):
        while (self.stateId != desiredState):

            match self.stateId:
                case LightSm.StateId.OFF:
                    self._OFF_exit()
                
                case LightSm.StateId.ON:
                    self._ON_exit()
                
                case _:
                    return  # Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
        
    
    
    
    ########################################
    # event handlers for state ROOT
    ########################################
    
    def _ROOT_enter(self):
        self.stateId = LightSm.StateId.ROOT
    
    
    
    ########################################
    # event handlers for state OFF
    ########################################
    
    def _OFF_enter(self):
        self.stateId = LightSm.StateId.OFF
        
        # OFF behavior
        # uml: enter / { bulb.set(False) }
        if True:
            # Step 1: execute action `bulb.set(False)`
            self.vars.bulb.set(False)
        # end of behavior for OFF
    
    
    def _OFF_exit(self):
        self.stateId = LightSm.StateId.ROOT
    
    
    def _OFF_toggle(self):
        # OFF behavior
        # uml: TOGGLE TransitionTo(ON)
        if True:
            # Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            self._OFF_exit()
            
            # Step 2: Transition action: ``.
            
            # Step 3: Enter/move towards transition target `ON`.
            self._ON_enter()
            
            # Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return
        # end of behavior for OFF
        
        # No ancestor handles this event.
    
    
    
    ########################################
    # event handlers for state ON
    ########################################
    
    def _ON_enter(self):
        self.stateId = LightSm.StateId.ON
        
        # ON behavior
        # uml: enter / { bulb.count += 1 }
        if True:
            # Step 1: execute action `bulb.count += 1`
            self.vars.bulb.count += 1
        # end of behavior for ON
        
        # ON behavior
        # uml: enter / { bulb.set(True) }
        if True:
            # Step 1: execute action `bulb.set(True)`
            self.vars.bulb.set(True)
        # end of behavior for ON
    
    
    def _ON_exit(self):
        self.stateId = LightSm.StateId.ROOT
    
    
    def _ON_toggle(self):
        # ON behavior
        # uml: TOGGLE TransitionTo(OFF)
        if True:
            # Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            self._ON_exit()
            
            # Step 2: Transition action: ``.
            
            # Step 3: Enter/move towards transition target `OFF`.
            self._OFF_enter()
            
            # Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return
        # end of behavior for ON
        
        # No ancestor handles this event.
    
    
    # Thread safe.
    @staticmethod
    def stateIdToString(id):
        match id:
            case LightSm.StateId.ROOT: return "ROOT"
            case LightSm.StateId.OFF: return "OFF"
            case LightSm.StateId.ON: return "ON"
            case _: return "?"
    
    
    # Thread safe.
    @staticmethod
    def eventIdToString(id):
        match id:
            case LightSm.EventId.TOGGLE: return "TOGGLE"
            case _: return "?"
    
