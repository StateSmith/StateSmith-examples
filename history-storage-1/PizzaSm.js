// Autogenerated with StateSmith 0.9.9-alpha.
// Algorithm: Balanced1. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// Generated state machine
class PizzaSm
{
    static EventId = 
    {
        BACK : 0,
        CANCEL : 1,
        NEXT : 2,
    }
    static { Object.freeze(this.EventId); }
    
    static EventIdCount = 3;
    static { Object.freeze(this.EventIdCount); }
    
    static StateId = 
    {
        ROOT : 0,
        ORDERED : 1,
        PIZZA_BUILD : 2,
        CRUST : 3,
        SIZE : 4,
        TOPPINGS : 5,
        PURCHASING : 6,
        CONFIRM_ORDER : 7,
        REVIEW_ORDER : 8,
    }
    static { Object.freeze(this.StateId); }
    
    static StateIdCount = 9;
    static { Object.freeze(this.StateIdCount); }
    
    static PizzaSm_HistoryId = 
    {
        PIZZA_BUILD : 0, // default transition
        PURCHASING : 1,
        ORDERED : 2,
        CRUST : 3,
        TOPPINGS : 4,
        SIZE : 5,
    }
    static { Object.freeze(this.PizzaSm_HistoryId); }
    
    // Used internally by state machine. Feel free to inspect, but don't modify.
    stateId;
    
    // Used internally by state machine. Don't modify.
    #ancestorEventHandler;
    
    // Used internally by state machine. Don't modify.
    #currentEventHandlers = Array(PizzaSm.EventIdCount).fill(undefined);
    
    // Used internally by state machine. Don't modify.
    #currentStateExitHandler;
    
    // Variables. Can be used for inputs, outputs, user variables...
    vars = {
        PizzaSm_history: undefined,
    };
    
    // Starts the state machine. Must be called before dispatching events. Not thread safe.
    start()
    {
        this.#ROOT_enter();
        // ROOT behavior
        // uml: TransitionTo(ROOT.<InitialState>)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
            // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
            
            // ROOT.<InitialState> behavior
            // uml: TransitionTo(ROOT.<History>)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `ROOT.<History>`.
                // ROOT.<History> is a pseudo state and cannot have an `enter` trigger.
                
                // ROOT.<History> behavior
                // uml: [$gil(this.vars.PizzaSm_history == PizzaSm_HistoryId.PURCHASING)] TransitionTo(PURCHASING)
                if (this.vars.PizzaSm_history == PizzaSm.PizzaSm_HistoryId.PURCHASING)
                {
                    // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                    
                    // Step 2: Transition action: ``.
                    
                    // Step 3: Enter/move towards transition target `PURCHASING`.
                    this.#PURCHASING_enter();
                    
                    // Finish transition by calling pseudo state transition function.
                    this.#PURCHASING_InitialState_transition();
                    return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
                } // end of behavior for ROOT.<History>
                
                // ROOT.<History> behavior
                // uml: [$gil(this.vars.PizzaSm_history == PizzaSm_HistoryId.ORDERED)] TransitionTo(ORDERED)
                if (this.vars.PizzaSm_history == PizzaSm.PizzaSm_HistoryId.ORDERED)
                {
                    // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                    
                    // Step 2: Transition action: ``.
                    
                    // Step 3: Enter/move towards transition target `ORDERED`.
                    this.#ORDERED_enter();
                    
                    // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                    this.stateId = PizzaSm.StateId.ORDERED;
                    // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
                    return;
                } // end of behavior for ROOT.<History>
                
                // ROOT.<History> behavior
                // uml: [$gil(this.vars.PizzaSm_history == PizzaSm_HistoryId.CRUST)] TransitionTo(CRUST)
                if (this.vars.PizzaSm_history == PizzaSm.PizzaSm_HistoryId.CRUST)
                {
                    // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                    
                    // Step 2: Transition action: ``.
                    
                    // Step 3: Enter/move towards transition target `CRUST`.
                    this.#PIZZA_BUILD_enter();
                    this.#CRUST_enter();
                    
                    // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                    this.stateId = PizzaSm.StateId.CRUST;
                    // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
                    return;
                } // end of behavior for ROOT.<History>
                
                // ROOT.<History> behavior
                // uml: [$gil(this.vars.PizzaSm_history == PizzaSm_HistoryId.TOPPINGS)] TransitionTo(TOPPINGS)
                if (this.vars.PizzaSm_history == PizzaSm.PizzaSm_HistoryId.TOPPINGS)
                {
                    // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                    
                    // Step 2: Transition action: ``.
                    
                    // Step 3: Enter/move towards transition target `TOPPINGS`.
                    this.#PIZZA_BUILD_enter();
                    this.#TOPPINGS_enter();
                    
                    // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                    this.stateId = PizzaSm.StateId.TOPPINGS;
                    // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
                    return;
                } // end of behavior for ROOT.<History>
                
                // ROOT.<History> behavior
                // uml: [$gil(this.vars.PizzaSm_history == PizzaSm_HistoryId.SIZE)] TransitionTo(SIZE)
                if (this.vars.PizzaSm_history == PizzaSm.PizzaSm_HistoryId.SIZE)
                {
                    // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                    
                    // Step 2: Transition action: ``.
                    
                    // Step 3: Enter/move towards transition target `SIZE`.
                    this.#PIZZA_BUILD_enter();
                    this.#SIZE_enter();
                    
                    // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                    this.stateId = PizzaSm.StateId.SIZE;
                    // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
                    return;
                } // end of behavior for ROOT.<History>
                
                // ROOT.<History> behavior
                // uml: else TransitionTo(PIZZA_BUILD)
                {
                    // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                    
                    // Step 2: Transition action: ``.
                    
                    // Step 3: Enter/move towards transition target `PIZZA_BUILD`.
                    this.#PIZZA_BUILD_enter();
                    
                    // Finish transition by calling pseudo state transition function.
                    this.#PIZZA_BUILD_InitialState_transition();
                    return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
                } // end of behavior for ROOT.<History>
            } // end of behavior for ROOT.<InitialState>
        } // end of behavior for ROOT
    }
    
    // Dispatches an event to the state machine. Not thread safe.
    dispatchEvent(eventId)
    {
        let behaviorFunc = this.#currentEventHandlers[eventId];
        
        while (behaviorFunc != null)
        {
            this.#ancestorEventHandler = null;
            behaviorFunc.call(this);
            behaviorFunc = this.#ancestorEventHandler;
        }
    }
    
    // This function is used when StateSmith doesn't know what the active leaf state is at
    // compile time due to sub states or when multiple states need to be exited.
    #exitUpToStateHandler(desiredStateExitHandler)
    {
        while (this.#currentStateExitHandler != desiredStateExitHandler)
        {
            this.#currentStateExitHandler.call(this);
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROOT
    ////////////////////////////////////////////////////////////////////////////////
    
    #ROOT_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#ROOT_exit;
    }
    
    #ROOT_exit()
    {
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ORDERED
    ////////////////////////////////////////////////////////////////////////////////
    
    #ORDERED_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#ORDERED_exit;
        this.#currentEventHandlers[PizzaSm.EventId.CANCEL] = this.#ORDERED_cancel;
        
        // ORDERED behavior
        // uml: enter / { show_ordered(); }
        {
            // Step 1: execute action `show_ordered();`
            show_ordered();
        } // end of behavior for ORDERED
        
        // ORDERED behavior
        // uml: enter / { $gil(this.vars.PizzaSm_history = PizzaSm_HistoryId.ORDERED;) }
        {
            // Step 1: execute action `$gil(this.vars.PizzaSm_history = PizzaSm_HistoryId.ORDERED;)`
            this.vars.PizzaSm_history = PizzaSm.PizzaSm_HistoryId.ORDERED;
        } // end of behavior for ORDERED
    }
    
    #ORDERED_exit()
    {
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#ROOT_exit;
        this.#currentEventHandlers[PizzaSm.EventId.CANCEL] = null;  // no ancestor listens to this event
    }
    
    #ORDERED_cancel()
    {
        // No ancestor state handles `cancel` event.
        
        // ORDERED behavior
        // uml: CANCEL TransitionTo(PIZZA_BUILD)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#ORDERED_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `PIZZA_BUILD`.
            this.#PIZZA_BUILD_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#PIZZA_BUILD_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ORDERED
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PIZZA_BUILD
    ////////////////////////////////////////////////////////////////////////////////
    
    #PIZZA_BUILD_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#PIZZA_BUILD_exit;
        
        // PIZZA_BUILD behavior
        // uml: enter / { console.log("PIZZA_BUILD entered"); }
        {
            // Step 1: execute action `console.log("PIZZA_BUILD entered");`
            console.log("PIZZA_BUILD entered");
        } // end of behavior for PIZZA_BUILD
        
        // PIZZA_BUILD behavior
        // uml: enter / { $gil(this.vars.PizzaSm_history = PizzaSm_HistoryId.PIZZA_BUILD;) }
        {
            // Step 1: execute action `$gil(this.vars.PizzaSm_history = PizzaSm_HistoryId.PIZZA_BUILD;)`
            this.vars.PizzaSm_history = PizzaSm.PizzaSm_HistoryId.PIZZA_BUILD;
        } // end of behavior for PIZZA_BUILD
    }
    
    #PIZZA_BUILD_exit()
    {
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#ROOT_exit;
    }
    
    #PIZZA_BUILD_InitialState_transition()
    {
        // PIZZA_BUILD.<InitialState> behavior
        // uml: TransitionTo(CRUST)
        {
            // Step 1: Exit states until we reach `PIZZA_BUILD` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `CRUST`.
            this.#CRUST_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = PizzaSm.StateId.CRUST;
            this.#ancestorEventHandler = null;
            return;
        } // end of behavior for PIZZA_BUILD.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state CRUST
    ////////////////////////////////////////////////////////////////////////////////
    
    #CRUST_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#CRUST_exit;
        this.#currentEventHandlers[PizzaSm.EventId.NEXT] = this.#CRUST_next;
        
        // CRUST behavior
        // uml: enter / { ask_crust(); }
        {
            // Step 1: execute action `ask_crust();`
            ask_crust();
        } // end of behavior for CRUST
        
        // CRUST behavior
        // uml: enter / { $gil(this.vars.PizzaSm_history = PizzaSm_HistoryId.CRUST;) }
        {
            // Step 1: execute action `$gil(this.vars.PizzaSm_history = PizzaSm_HistoryId.CRUST;)`
            this.vars.PizzaSm_history = PizzaSm.PizzaSm_HistoryId.CRUST;
        } // end of behavior for CRUST
    }
    
    #CRUST_exit()
    {
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#PIZZA_BUILD_exit;
        this.#currentEventHandlers[PizzaSm.EventId.NEXT] = null;  // no ancestor listens to this event
    }
    
    #CRUST_next()
    {
        // No ancestor state handles `next` event.
        
        // CRUST behavior
        // uml: NEXT TransitionTo(SIZE)
        {
            // Step 1: Exit states until we reach `PIZZA_BUILD` state (Least Common Ancestor for transition).
            this.#CRUST_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `SIZE`.
            this.#SIZE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = PizzaSm.StateId.SIZE;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for CRUST
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SIZE
    ////////////////////////////////////////////////////////////////////////////////
    
    #SIZE_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#SIZE_exit;
        this.#currentEventHandlers[PizzaSm.EventId.BACK] = this.#SIZE_back;
        this.#currentEventHandlers[PizzaSm.EventId.NEXT] = this.#SIZE_next;
        
        // SIZE behavior
        // uml: enter / { ask_size(); }
        {
            // Step 1: execute action `ask_size();`
            ask_size();
        } // end of behavior for SIZE
        
        // SIZE behavior
        // uml: enter / { $gil(this.vars.PizzaSm_history = PizzaSm_HistoryId.SIZE;) }
        {
            // Step 1: execute action `$gil(this.vars.PizzaSm_history = PizzaSm_HistoryId.SIZE;)`
            this.vars.PizzaSm_history = PizzaSm.PizzaSm_HistoryId.SIZE;
        } // end of behavior for SIZE
    }
    
    #SIZE_exit()
    {
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#PIZZA_BUILD_exit;
        this.#currentEventHandlers[PizzaSm.EventId.BACK] = null;  // no ancestor listens to this event
        this.#currentEventHandlers[PizzaSm.EventId.NEXT] = null;  // no ancestor listens to this event
    }
    
    #SIZE_back()
    {
        // No ancestor state handles `back` event.
        
        // SIZE behavior
        // uml: BACK TransitionTo(CRUST)
        {
            // Step 1: Exit states until we reach `PIZZA_BUILD` state (Least Common Ancestor for transition).
            this.#SIZE_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `CRUST`.
            this.#CRUST_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = PizzaSm.StateId.CRUST;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for SIZE
    }
    
    #SIZE_next()
    {
        // No ancestor state handles `next` event.
        
        // SIZE behavior
        // uml: NEXT TransitionTo(TOPPINGS)
        {
            // Step 1: Exit states until we reach `PIZZA_BUILD` state (Least Common Ancestor for transition).
            this.#SIZE_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `TOPPINGS`.
            this.#TOPPINGS_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = PizzaSm.StateId.TOPPINGS;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for SIZE
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state TOPPINGS
    ////////////////////////////////////////////////////////////////////////////////
    
    #TOPPINGS_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#TOPPINGS_exit;
        this.#currentEventHandlers[PizzaSm.EventId.BACK] = this.#TOPPINGS_back;
        this.#currentEventHandlers[PizzaSm.EventId.NEXT] = this.#TOPPINGS_next;
        
        // TOPPINGS behavior
        // uml: enter / { ask_toppings(); }
        {
            // Step 1: execute action `ask_toppings();`
            ask_toppings();
        } // end of behavior for TOPPINGS
        
        // TOPPINGS behavior
        // uml: enter / { $gil(this.vars.PizzaSm_history = PizzaSm_HistoryId.TOPPINGS;) }
        {
            // Step 1: execute action `$gil(this.vars.PizzaSm_history = PizzaSm_HistoryId.TOPPINGS;)`
            this.vars.PizzaSm_history = PizzaSm.PizzaSm_HistoryId.TOPPINGS;
        } // end of behavior for TOPPINGS
    }
    
    #TOPPINGS_exit()
    {
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#PIZZA_BUILD_exit;
        this.#currentEventHandlers[PizzaSm.EventId.BACK] = null;  // no ancestor listens to this event
        this.#currentEventHandlers[PizzaSm.EventId.NEXT] = null;  // no ancestor listens to this event
    }
    
    #TOPPINGS_back()
    {
        // No ancestor state handles `back` event.
        
        // TOPPINGS behavior
        // uml: BACK TransitionTo(SIZE)
        {
            // Step 1: Exit states until we reach `PIZZA_BUILD` state (Least Common Ancestor for transition).
            this.#TOPPINGS_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `SIZE`.
            this.#SIZE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = PizzaSm.StateId.SIZE;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for TOPPINGS
    }
    
    #TOPPINGS_next()
    {
        // No ancestor state handles `next` event.
        
        // TOPPINGS behavior
        // uml: NEXT TransitionTo(PIZZA_BUILD.<ExitPoint>(done))
        {
            // Step 1: Exit states until we reach `PIZZA_BUILD` state (Least Common Ancestor for transition).
            this.#TOPPINGS_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `PIZZA_BUILD.<ExitPoint>(done)`.
            // PIZZA_BUILD.<ExitPoint>(done) is a pseudo state and cannot have an `enter` trigger.
            
            // PIZZA_BUILD.<ExitPoint>(done) behavior
            // uml: TransitionTo(PURCHASING)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                this.#PIZZA_BUILD_exit();
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `PURCHASING`.
                this.#PURCHASING_enter();
                
                // Finish transition by calling pseudo state transition function.
                this.#PURCHASING_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for PIZZA_BUILD.<ExitPoint>(done)
        } // end of behavior for TOPPINGS
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PURCHASING
    ////////////////////////////////////////////////////////////////////////////////
    
    #PURCHASING_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#PURCHASING_exit;
        this.#currentEventHandlers[PizzaSm.EventId.BACK] = this.#PURCHASING_back;
        
        // PURCHASING behavior
        // uml: enter / { $gil(this.vars.PizzaSm_history = PizzaSm_HistoryId.PURCHASING;) }
        {
            // Step 1: execute action `$gil(this.vars.PizzaSm_history = PizzaSm_HistoryId.PURCHASING;)`
            this.vars.PizzaSm_history = PizzaSm.PizzaSm_HistoryId.PURCHASING;
        } // end of behavior for PURCHASING
    }
    
    #PURCHASING_exit()
    {
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#ROOT_exit;
        this.#currentEventHandlers[PizzaSm.EventId.BACK] = null;  // no ancestor listens to this event
    }
    
    #PURCHASING_back()
    {
        // No ancestor state handles `back` event.
        
        // PURCHASING behavior
        // uml: BACK TransitionTo(PIZZA_BUILD.<EntryPoint>(from_back))
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(this.#ROOT_exit);
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `PIZZA_BUILD.<EntryPoint>(from_back)`.
            this.#PIZZA_BUILD_enter();
            // PIZZA_BUILD.<EntryPoint>(from_back) is a pseudo state and cannot have an `enter` trigger.
            
            // PIZZA_BUILD.<EntryPoint>(from_back) behavior
            // uml: TransitionTo(TOPPINGS)
            {
                // Step 1: Exit states until we reach `PIZZA_BUILD` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `TOPPINGS`.
                this.#TOPPINGS_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = PizzaSm.StateId.TOPPINGS;
                // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
                return;
            } // end of behavior for PIZZA_BUILD.<EntryPoint>(from_back)
        } // end of behavior for PURCHASING
    }
    
    #PURCHASING_InitialState_transition()
    {
        // PURCHASING.<InitialState> behavior
        // uml: TransitionTo(REVIEW_ORDER)
        {
            // Step 1: Exit states until we reach `PURCHASING` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `REVIEW_ORDER`.
            this.#REVIEW_ORDER_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = PizzaSm.StateId.REVIEW_ORDER;
            this.#ancestorEventHandler = null;
            return;
        } // end of behavior for PURCHASING.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state CONFIRM_ORDER
    ////////////////////////////////////////////////////////////////////////////////
    
    #CONFIRM_ORDER_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#CONFIRM_ORDER_exit;
        this.#currentEventHandlers[PizzaSm.EventId.BACK] = this.#CONFIRM_ORDER_back;
        this.#currentEventHandlers[PizzaSm.EventId.NEXT] = this.#CONFIRM_ORDER_next;
        
        // CONFIRM_ORDER behavior
        // uml: enter / { ask_confirmation(); }
        {
            // Step 1: execute action `ask_confirmation();`
            ask_confirmation();
        } // end of behavior for CONFIRM_ORDER
    }
    
    #CONFIRM_ORDER_exit()
    {
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#PURCHASING_exit;
        this.#currentEventHandlers[PizzaSm.EventId.BACK] = this.#PURCHASING_back;  // the next ancestor that handles this event is PURCHASING
        this.#currentEventHandlers[PizzaSm.EventId.NEXT] = null;  // no ancestor listens to this event
    }
    
    #CONFIRM_ORDER_back()
    {
        // Setup handler for next ancestor that listens to `back` event.
        this.#ancestorEventHandler = this.#PURCHASING_back;
        
        // CONFIRM_ORDER behavior
        // uml: BACK TransitionTo(REVIEW_ORDER)
        {
            // Step 1: Exit states until we reach `PURCHASING` state (Least Common Ancestor for transition).
            this.#CONFIRM_ORDER_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `REVIEW_ORDER`.
            this.#REVIEW_ORDER_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = PizzaSm.StateId.REVIEW_ORDER;
            this.#ancestorEventHandler = null;
            return;
        } // end of behavior for CONFIRM_ORDER
    }
    
    #CONFIRM_ORDER_next()
    {
        // No ancestor state handles `next` event.
        
        // CONFIRM_ORDER behavior
        // uml: NEXT TransitionTo(PURCHASING.<ExitPoint>(done))
        {
            // Step 1: Exit states until we reach `PURCHASING` state (Least Common Ancestor for transition).
            this.#CONFIRM_ORDER_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `PURCHASING.<ExitPoint>(done)`.
            // PURCHASING.<ExitPoint>(done) is a pseudo state and cannot have an `enter` trigger.
            
            // PURCHASING.<ExitPoint>(done) behavior
            // uml: TransitionTo(ORDERED)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                this.#PURCHASING_exit();
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `ORDERED`.
                this.#ORDERED_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = PizzaSm.StateId.ORDERED;
                // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
                return;
            } // end of behavior for PURCHASING.<ExitPoint>(done)
        } // end of behavior for CONFIRM_ORDER
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state REVIEW_ORDER
    ////////////////////////////////////////////////////////////////////////////////
    
    #REVIEW_ORDER_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#REVIEW_ORDER_exit;
        this.#currentEventHandlers[PizzaSm.EventId.NEXT] = this.#REVIEW_ORDER_next;
        
        // REVIEW_ORDER behavior
        // uml: enter / { ask_review_order(); }
        {
            // Step 1: execute action `ask_review_order();`
            ask_review_order();
        } // end of behavior for REVIEW_ORDER
    }
    
    #REVIEW_ORDER_exit()
    {
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#PURCHASING_exit;
        this.#currentEventHandlers[PizzaSm.EventId.NEXT] = null;  // no ancestor listens to this event
    }
    
    #REVIEW_ORDER_next()
    {
        // No ancestor state handles `next` event.
        
        // REVIEW_ORDER behavior
        // uml: NEXT TransitionTo(CONFIRM_ORDER)
        {
            // Step 1: Exit states until we reach `PURCHASING` state (Least Common Ancestor for transition).
            this.#REVIEW_ORDER_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `CONFIRM_ORDER`.
            this.#CONFIRM_ORDER_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = PizzaSm.StateId.CONFIRM_ORDER;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for REVIEW_ORDER
    }
    
    // Thread safe.
    static stateIdToString(id)
    {
        switch (id)
        {
            case PizzaSm.StateId.ROOT: return "ROOT";
            case PizzaSm.StateId.ORDERED: return "ORDERED";
            case PizzaSm.StateId.PIZZA_BUILD: return "PIZZA_BUILD";
            case PizzaSm.StateId.CRUST: return "CRUST";
            case PizzaSm.StateId.SIZE: return "SIZE";
            case PizzaSm.StateId.TOPPINGS: return "TOPPINGS";
            case PizzaSm.StateId.PURCHASING: return "PURCHASING";
            case PizzaSm.StateId.CONFIRM_ORDER: return "CONFIRM_ORDER";
            case PizzaSm.StateId.REVIEW_ORDER: return "REVIEW_ORDER";
            default: return "?";
        }
    }
    
    // Thread safe.
    static eventIdToString(id)
    {
        switch (id)
        {
            case PizzaSm.EventId.BACK: return "BACK";
            case PizzaSm.EventId.CANCEL: return "CANCEL";
            case PizzaSm.EventId.NEXT: return "NEXT";
            default: return "?";
        }
    }
}
