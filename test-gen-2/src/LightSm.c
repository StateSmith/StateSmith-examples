// Autogenerated with StateSmith 0.9.14-alpha+1f116014cd5077a4daa688d05b563fe0be54ef0c.
// Algorithm: Balanced1. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// User RenderConfig CFileTop text...
#include "LightSm.h"
// User RenderConfig CFileIncludes text...
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(LightSm* sm, LightSm_Func desired_state_exit_handler);

static void ROOT_enter(LightSm* sm);

static void ROOT_exit(LightSm* sm);

static void ORDER_MENU_enter(LightSm* sm);

static void ORDER_MENU_exit(LightSm* sm);

static void ORDER_MENU_ev3(LightSm* sm);

static void BEVERAGE_enter(LightSm* sm);

static void BEVERAGE_exit(LightSm* sm);

static void BEVERAGE_ev2(LightSm* sm);

static void BEVERAGE_InitialState_transition(LightSm* sm);

static void COFFEE_enter(LightSm* sm);

static void COFFEE_exit(LightSm* sm);

static void COFFEE_ev1(LightSm* sm);

static void TEA_enter(LightSm* sm);

static void TEA_exit(LightSm* sm);

static void TEA_ev1(LightSm* sm);

static void TEA_ev2(LightSm* sm);

static void WATER_enter(LightSm* sm);

static void WATER_exit(LightSm* sm);

static void WATER_ev1(LightSm* sm);

static void FOOD_enter(LightSm* sm);

static void FOOD_exit(LightSm* sm);

static void FOOD_escape(LightSm* sm);

static void FOOD_ev2(LightSm* sm);

static void FOOD_InitialState_transition(LightSm* sm);

static void JUNK_enter(LightSm* sm);

static void JUNK_exit(LightSm* sm);

static void JUNK_ev1(LightSm* sm);

static void POTATO_enter(LightSm* sm);

static void POTATO_exit(LightSm* sm);

static void POTATO_ev1(LightSm* sm);

static void SUSHI_enter(LightSm* sm);

static void SUSHI_exit(LightSm* sm);

static void SUSHI_ev1(LightSm* sm);

static void WAITING_enter(LightSm* sm);

static void WAITING_exit(LightSm* sm);

static void WAITING_ev3(LightSm* sm);


// State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
void LightSm_ctor(LightSm* sm)
{
    memset(sm, 0, sizeof(*sm));
}

// Starts the state machine. Must be called before dispatching events. Not thread safe.
void LightSm_start(LightSm* sm)
{
    ROOT_enter(sm);
    // ROOT behavior
    // uml: TransitionTo(ROOT.<InitialState>)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
        // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<InitialState> behavior
        // uml: TransitionTo(WAITING)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `WAITING`.
            WAITING_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = LightSm_StateId_WAITING;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for ROOT.<InitialState>
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
void LightSm_dispatch_event(LightSm* sm, LightSm_EventId event_id)
{
    LightSm_Func behavior_func = sm->current_event_handlers[event_id];
    
    while (behavior_func != NULL)
    {
        sm->ancestor_event_handler = NULL;
        behavior_func(sm);
        behavior_func = sm->ancestor_event_handler;
    }
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(LightSm* sm, LightSm_Func desired_state_exit_handler)
{
    while (sm->current_state_exit_handler != desired_state_exit_handler)
    {
        sm->current_state_exit_handler(sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(LightSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = ROOT_exit;
}

static void ROOT_exit(LightSm* sm)
{
    // State machine root is a special case. It cannot be exited. Mark as unused.
    (void)sm;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ORDER_MENU
////////////////////////////////////////////////////////////////////////////////

static void ORDER_MENU_enter(LightSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = ORDER_MENU_exit;
    sm->current_event_handlers[LightSm_EventId_EV3] = ORDER_MENU_ev3;
}

static void ORDER_MENU_exit(LightSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[LightSm_EventId_EV3] = NULL;  // no ancestor listens to this event
}

static void ORDER_MENU_ev3(LightSm* sm)
{
    // No ancestor state handles `ev3` event.
    
    // ORDER_MENU behavior
    // uml: EV3 TransitionTo(WAITING)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WAITING`.
        WAITING_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LightSm_StateId_WAITING;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for ORDER_MENU
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state BEVERAGE
////////////////////////////////////////////////////////////////////////////////

static void BEVERAGE_enter(LightSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = BEVERAGE_exit;
    sm->current_event_handlers[LightSm_EventId_EV2] = BEVERAGE_ev2;
    
    // BEVERAGE behavior
    // uml: enter / { $gil(this.vars.ORDER_MENU_history = ORDER_MENU_HistoryId.BEVERAGE;) }
    {
        // Step 1: execute action `$gil(this.vars.ORDER_MENU_history = ORDER_MENU_HistoryId.BEVERAGE;)`
        sm->vars.ORDER_MENU_history = LightSm_ORDER_MENU_HistoryId_BEVERAGE;
    } // end of behavior for BEVERAGE
}

static void BEVERAGE_exit(LightSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ORDER_MENU_exit;
    sm->current_event_handlers[LightSm_EventId_EV2] = NULL;  // no ancestor listens to this event
}

static void BEVERAGE_ev2(LightSm* sm)
{
    // No ancestor state handles `ev2` event.
    
    // BEVERAGE behavior
    // uml: EV2 TransitionTo(FOOD)
    {
        // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ORDER_MENU_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `FOOD`.
        FOOD_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        FOOD_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for BEVERAGE
}

static void BEVERAGE_InitialState_transition(LightSm* sm)
{
    // BEVERAGE.<InitialState> behavior
    // uml: TransitionTo(WATER)
    {
        // Step 1: Exit states until we reach `BEVERAGE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WATER`.
        WATER_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LightSm_StateId_WATER;
        sm->ancestor_event_handler = NULL;
        return;
    } // end of behavior for BEVERAGE.<InitialState>
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state COFFEE
////////////////////////////////////////////////////////////////////////////////

static void COFFEE_enter(LightSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = COFFEE_exit;
    sm->current_event_handlers[LightSm_EventId_EV1] = COFFEE_ev1;
    
    // COFFEE behavior
    // uml: enter / { /*do_x();*/ }
    {
        // Step 1: execute action `/*do_x();*/`
        /*do_x();*/
    } // end of behavior for COFFEE
    
    // COFFEE behavior
    // uml: enter / { $gil(this.vars.ORDER_MENU_history = ORDER_MENU_HistoryId.COFFEE;) }
    {
        // Step 1: execute action `$gil(this.vars.ORDER_MENU_history = ORDER_MENU_HistoryId.COFFEE;)`
        sm->vars.ORDER_MENU_history = LightSm_ORDER_MENU_HistoryId_COFFEE;
    } // end of behavior for COFFEE
}

static void COFFEE_exit(LightSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = BEVERAGE_exit;
    sm->current_event_handlers[LightSm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void COFFEE_ev1(LightSm* sm)
{
    // No ancestor state handles `ev1` event.
    
    // COFFEE behavior
    // uml: EV1 TransitionTo(TEA)
    {
        // Step 1: Exit states until we reach `BEVERAGE` state (Least Common Ancestor for transition).
        COFFEE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `TEA`.
        TEA_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LightSm_StateId_TEA;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for COFFEE
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEA
////////////////////////////////////////////////////////////////////////////////

static void TEA_enter(LightSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = TEA_exit;
    sm->current_event_handlers[LightSm_EventId_EV1] = TEA_ev1;
    sm->current_event_handlers[LightSm_EventId_EV2] = TEA_ev2;
    
    // TEA behavior
    // uml: enter / { $gil(this.vars.ORDER_MENU_history = ORDER_MENU_HistoryId.TEA;) }
    {
        // Step 1: execute action `$gil(this.vars.ORDER_MENU_history = ORDER_MENU_HistoryId.TEA;)`
        sm->vars.ORDER_MENU_history = LightSm_ORDER_MENU_HistoryId_TEA;
    } // end of behavior for TEA
}

static void TEA_exit(LightSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = BEVERAGE_exit;
    sm->current_event_handlers[LightSm_EventId_EV1] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[LightSm_EventId_EV2] = BEVERAGE_ev2;  // the next ancestor that handles this event is BEVERAGE
}

static void TEA_ev1(LightSm* sm)
{
    // No ancestor state handles `ev1` event.
    
    // TEA behavior
    // uml: EV1 TransitionTo(COFFEE)
    {
        // Step 1: Exit states until we reach `BEVERAGE` state (Least Common Ancestor for transition).
        TEA_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `COFFEE`.
        COFFEE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LightSm_StateId_COFFEE;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for TEA
}

static void TEA_ev2(LightSm* sm)
{
    // Setup handler for next ancestor that listens to `ev2` event.
    sm->ancestor_event_handler = BEVERAGE_ev2;
    
    // TEA behavior
    // uml: EV2 TransitionTo(BEVERAGE.<InitialState>)
    {
        // Step 1: Exit states until we reach `BEVERAGE` state (Least Common Ancestor for transition).
        TEA_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `BEVERAGE.<InitialState>`.
        // BEVERAGE.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        BEVERAGE_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEA
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state WATER
////////////////////////////////////////////////////////////////////////////////

static void WATER_enter(LightSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = WATER_exit;
    sm->current_event_handlers[LightSm_EventId_EV1] = WATER_ev1;
    
    // WATER behavior
    // uml: enter / { $gil(this.vars.ORDER_MENU_history = ORDER_MENU_HistoryId.WATER;) }
    {
        // Step 1: execute action `$gil(this.vars.ORDER_MENU_history = ORDER_MENU_HistoryId.WATER;)`
        sm->vars.ORDER_MENU_history = LightSm_ORDER_MENU_HistoryId_WATER;
    } // end of behavior for WATER
}

static void WATER_exit(LightSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = BEVERAGE_exit;
    sm->current_event_handlers[LightSm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void WATER_ev1(LightSm* sm)
{
    // No ancestor state handles `ev1` event.
    
    // WATER behavior
    // uml: EV1 TransitionTo(COFFEE)
    {
        // Step 1: Exit states until we reach `BEVERAGE` state (Least Common Ancestor for transition).
        WATER_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `COFFEE`.
        COFFEE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LightSm_StateId_COFFEE;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for WATER
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state FOOD
////////////////////////////////////////////////////////////////////////////////

static void FOOD_enter(LightSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = FOOD_exit;
    sm->current_event_handlers[LightSm_EventId_ESCAPE] = FOOD_escape;
    sm->current_event_handlers[LightSm_EventId_EV2] = FOOD_ev2;
    
    // FOOD behavior
    // uml: enter / { $gil(this.vars.ORDER_MENU_history = ORDER_MENU_HistoryId.FOOD;) }
    {
        // Step 1: execute action `$gil(this.vars.ORDER_MENU_history = ORDER_MENU_HistoryId.FOOD;)`
        sm->vars.ORDER_MENU_history = LightSm_ORDER_MENU_HistoryId_FOOD;
    } // end of behavior for FOOD
}

static void FOOD_exit(LightSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ORDER_MENU_exit;
    sm->current_event_handlers[LightSm_EventId_ESCAPE] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[LightSm_EventId_EV2] = NULL;  // no ancestor listens to this event
}

static void FOOD_escape(LightSm* sm)
{
    // No ancestor state handles `escape` event.
    
    // FOOD behavior
    // uml: ESCAPE TransitionTo(ORDER_MENU.<ExitPoint>(1))
    {
        // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ORDER_MENU_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ORDER_MENU.<ExitPoint>(1)`.
        // ORDER_MENU.<ExitPoint>(1) is a pseudo state and cannot have an `enter` trigger.
        
        // ORDER_MENU.<ExitPoint>(1) behavior
        // uml: TransitionTo(WAITING)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            ORDER_MENU_exit(sm);
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `WAITING`.
            WAITING_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = LightSm_StateId_WAITING;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for ORDER_MENU.<ExitPoint>(1)
    } // end of behavior for FOOD
}

static void FOOD_ev2(LightSm* sm)
{
    // No ancestor state handles `ev2` event.
    
    // FOOD behavior
    // uml: EV2 TransitionTo(ORDER_MENU.<ChoicePoint>(bev_choice))
    {
        // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ORDER_MENU_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ORDER_MENU.<ChoicePoint>(bev_choice)`.
        // ORDER_MENU.<ChoicePoint>(bev_choice) is a pseudo state and cannot have an `enter` trigger.
        
        // ORDER_MENU.<ChoicePoint>(bev_choice) behavior
        // uml: [a > b] TransitionTo(TEA)
        if (a > b)
        {
            // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `TEA`.
            BEVERAGE_enter(sm);
            TEA_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = LightSm_StateId_TEA;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for ORDER_MENU.<ChoicePoint>(bev_choice)
        
        // ORDER_MENU.<ChoicePoint>(bev_choice) behavior
        // uml: else TransitionTo(BEVERAGE)
        {
            // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `BEVERAGE`.
            BEVERAGE_enter(sm);
            
            // Finish transition by calling pseudo state transition function.
            BEVERAGE_InitialState_transition(sm);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ORDER_MENU.<ChoicePoint>(bev_choice)
    } // end of behavior for FOOD
}

static void FOOD_InitialState_transition(LightSm* sm)
{
    // FOOD.<InitialState> behavior
    // uml: TransitionTo(JUNK)
    {
        // Step 1: Exit states until we reach `FOOD` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `JUNK`.
        JUNK_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LightSm_StateId_JUNK;
        sm->ancestor_event_handler = NULL;
        return;
    } // end of behavior for FOOD.<InitialState>
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state JUNK
////////////////////////////////////////////////////////////////////////////////

static void JUNK_enter(LightSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = JUNK_exit;
    sm->current_event_handlers[LightSm_EventId_EV1] = JUNK_ev1;
}

static void JUNK_exit(LightSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = FOOD_exit;
    sm->current_event_handlers[LightSm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void JUNK_ev1(LightSm* sm)
{
    // No ancestor state handles `ev1` event.
    
    // JUNK behavior
    // uml: EV1 TransitionTo(POTATO)
    {
        // Step 1: Exit states until we reach `FOOD` state (Least Common Ancestor for transition).
        JUNK_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `POTATO`.
        POTATO_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LightSm_StateId_POTATO;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for JUNK
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state POTATO
////////////////////////////////////////////////////////////////////////////////

static void POTATO_enter(LightSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = POTATO_exit;
    sm->current_event_handlers[LightSm_EventId_EV1] = POTATO_ev1;
}

static void POTATO_exit(LightSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = FOOD_exit;
    sm->current_event_handlers[LightSm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void POTATO_ev1(LightSm* sm)
{
    // No ancestor state handles `ev1` event.
    
    // POTATO behavior
    // uml: EV1 TransitionTo(SUSHI)
    {
        // Step 1: Exit states until we reach `FOOD` state (Least Common Ancestor for transition).
        POTATO_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `SUSHI`.
        SUSHI_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LightSm_StateId_SUSHI;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for POTATO
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SUSHI
////////////////////////////////////////////////////////////////////////////////

static void SUSHI_enter(LightSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = SUSHI_exit;
    sm->current_event_handlers[LightSm_EventId_EV1] = SUSHI_ev1;
}

static void SUSHI_exit(LightSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = FOOD_exit;
    sm->current_event_handlers[LightSm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void SUSHI_ev1(LightSm* sm)
{
    // No ancestor state handles `ev1` event.
    
    // SUSHI behavior
    // uml: EV1 TransitionTo(JUNK)
    {
        // Step 1: Exit states until we reach `FOOD` state (Least Common Ancestor for transition).
        SUSHI_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `JUNK`.
        JUNK_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LightSm_StateId_JUNK;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for SUSHI
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state WAITING
////////////////////////////////////////////////////////////////////////////////

static void WAITING_enter(LightSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = WAITING_exit;
    sm->current_event_handlers[LightSm_EventId_EV3] = WAITING_ev3;
}

static void WAITING_exit(LightSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[LightSm_EventId_EV3] = NULL;  // no ancestor listens to this event
}

static void WAITING_ev3(LightSm* sm)
{
    // No ancestor state handles `ev3` event.
    
    // WAITING behavior
    // uml: EV3 TransitionTo(ORDER_MENU.<EntryPoint>(to_history))
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        WAITING_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ORDER_MENU.<EntryPoint>(to_history)`.
        ORDER_MENU_enter(sm);
        // ORDER_MENU.<EntryPoint>(to_history) is a pseudo state and cannot have an `enter` trigger.
        
        // ORDER_MENU.<EntryPoint>(to_history) behavior
        // uml: TransitionTo(ORDER_MENU.<History>)
        {
            // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ORDER_MENU.<History>`.
            // ORDER_MENU.<History> is a pseudo state and cannot have an `enter` trigger.
            
            // ORDER_MENU.<History> behavior
            // uml: [$gil(this.vars.ORDER_MENU_history == ORDER_MENU_HistoryId.FOOD)] TransitionTo(FOOD)
            if (sm->vars.ORDER_MENU_history == LightSm_ORDER_MENU_HistoryId_FOOD)
            {
                // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `FOOD`.
                FOOD_enter(sm);
                
                // Finish transition by calling pseudo state transition function.
                FOOD_InitialState_transition(sm);
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for ORDER_MENU.<History>
            
            // ORDER_MENU.<History> behavior
            // uml: [$gil(this.vars.ORDER_MENU_history == ORDER_MENU_HistoryId.WATER)] TransitionTo(WATER)
            if (sm->vars.ORDER_MENU_history == LightSm_ORDER_MENU_HistoryId_WATER)
            {
                // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `WATER`.
                BEVERAGE_enter(sm);
                WATER_enter(sm);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                sm->state_id = LightSm_StateId_WATER;
                // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
                return;
            } // end of behavior for ORDER_MENU.<History>
            
            // ORDER_MENU.<History> behavior
            // uml: [$gil(this.vars.ORDER_MENU_history == ORDER_MENU_HistoryId.COFFEE)] TransitionTo(COFFEE)
            if (sm->vars.ORDER_MENU_history == LightSm_ORDER_MENU_HistoryId_COFFEE)
            {
                // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `COFFEE`.
                BEVERAGE_enter(sm);
                COFFEE_enter(sm);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                sm->state_id = LightSm_StateId_COFFEE;
                // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
                return;
            } // end of behavior for ORDER_MENU.<History>
            
            // ORDER_MENU.<History> behavior
            // uml: [$gil(this.vars.ORDER_MENU_history == ORDER_MENU_HistoryId.TEA)] TransitionTo(TEA)
            if (sm->vars.ORDER_MENU_history == LightSm_ORDER_MENU_HistoryId_TEA)
            {
                // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `TEA`.
                BEVERAGE_enter(sm);
                TEA_enter(sm);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                sm->state_id = LightSm_StateId_TEA;
                // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
                return;
            } // end of behavior for ORDER_MENU.<History>
            
            // ORDER_MENU.<History> behavior
            // uml: else TransitionTo(BEVERAGE)
            {
                // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `BEVERAGE`.
                BEVERAGE_enter(sm);
                
                // Finish transition by calling pseudo state transition function.
                BEVERAGE_InitialState_transition(sm);
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for ORDER_MENU.<History>
        } // end of behavior for ORDER_MENU.<EntryPoint>(to_history)
    } // end of behavior for WAITING
}

// Thread safe.
char const * LightSm_state_id_to_string(LightSm_StateId id)
{
    switch (id)
    {
        case LightSm_StateId_ROOT: return "ROOT";
        case LightSm_StateId_ORDER_MENU: return "ORDER_MENU";
        case LightSm_StateId_BEVERAGE: return "BEVERAGE";
        case LightSm_StateId_COFFEE: return "COFFEE";
        case LightSm_StateId_TEA: return "TEA";
        case LightSm_StateId_WATER: return "WATER";
        case LightSm_StateId_FOOD: return "FOOD";
        case LightSm_StateId_JUNK: return "JUNK";
        case LightSm_StateId_POTATO: return "POTATO";
        case LightSm_StateId_SUSHI: return "SUSHI";
        case LightSm_StateId_WAITING: return "WAITING";
        default: return "?";
    }
}

// Thread safe.
char const * LightSm_event_id_to_string(LightSm_EventId id)
{
    switch (id)
    {
        case LightSm_EventId_ESCAPE: return "ESCAPE";
        case LightSm_EventId_EV1: return "EV1";
        case LightSm_EventId_EV2: return "EV2";
        case LightSm_EventId_EV3: return "EV3";
        default: return "?";
    }
}
