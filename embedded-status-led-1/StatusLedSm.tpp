// Autogenerated with StateSmith 0.11.2-alpha+4a4e30018e9a371124530fa96cf2ba3322b80459.
// Algorithm: Balanced1. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

#include "StatusLedSm.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(StatusLedSm* sm, StatusLedSm_Func desired_state_exit_handler);

static void ROOT_enter(StatusLedSm* sm);

static void ROOT_exit(StatusLedSm* sm);

static void ROOT_ChoicePoint_ROUTE__transition(StatusLedSm* sm);

static void ROOT_ChoicePoint_RETURN__transition(StatusLedSm* sm);

static void BOOT1_enter(StatusLedSm* sm);

static void BOOT1_exit(StatusLedSm* sm);

static void BOOT1_do(StatusLedSm* sm);

static void BOOT2_enter(StatusLedSm* sm);

static void BOOT2_exit(StatusLedSm* sm);

static void BOOT2_do(StatusLedSm* sm);

static void ERROR_SEQ1_enter(StatusLedSm* sm);

static void ERROR_SEQ1_exit(StatusLedSm* sm);

static void ERROR_SEQ1_do(StatusLedSm* sm);

static void ERROR_SEQ2_enter(StatusLedSm* sm);

static void ERROR_SEQ2_exit(StatusLedSm* sm);

static void ERROR_SEQ2_do(StatusLedSm* sm);

static void ERROR_SEQ3_enter(StatusLedSm* sm);

static void ERROR_SEQ3_exit(StatusLedSm* sm);

static void ERROR_SEQ3_do(StatusLedSm* sm);

static void RUNNING_GROUP_enter(StatusLedSm* sm);

static void RUNNING_GROUP_exit(StatusLedSm* sm);

static void RUNNING_OK_enter(StatusLedSm* sm);

static void RUNNING_OK_exit(StatusLedSm* sm);

static void RUNNING_OK_do(StatusLedSm* sm);

static void RUNNING_OK_SEQ2_enter(StatusLedSm* sm);

static void RUNNING_OK_SEQ2_exit(StatusLedSm* sm);

static void RUNNING_OK_SEQ2_do(StatusLedSm* sm);

static void WARNING_enter(StatusLedSm* sm);

static void WARNING_exit(StatusLedSm* sm);

static void WARNING_do(StatusLedSm* sm);

static void WARNING_SEQ2_enter(StatusLedSm* sm);

static void WARNING_SEQ2_exit(StatusLedSm* sm);

static void WARNING_SEQ2_do(StatusLedSm* sm);


// State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
void StatusLedSm_ctor(StatusLedSm* sm)
{
    memset(sm, 0, sizeof(*sm));
}

// Starts the state machine. Must be called before dispatching events. Not thread safe.
void StatusLedSm_start(StatusLedSm* sm)
{
    ROOT_enter(sm);
    // ROOT behavior
    // uml: TransitionTo(ROOT.<InitialState>)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
        // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<InitialState> behavior
        // uml: TransitionTo(ROOT.<ChoicePoint>(ROUTE))
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ROOT.<ChoicePoint>(ROUTE)`.
            // ROOT.<ChoicePoint>(ROUTE) is a pseudo state and cannot have an `enter` trigger.
            
            // Finish transition by calling pseudo state transition function.
            ROOT_ChoicePoint_ROUTE__transition(sm);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ROOT.<InitialState>
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
void StatusLedSm_dispatch_event(StatusLedSm* sm, StatusLedSm_EventId event_id)
{
    StatusLedSm_Func behavior_func = sm->current_event_handlers[event_id];
    
    while (behavior_func != NULL)
    {
        sm->ancestor_event_handler = NULL;
        behavior_func(sm);
        behavior_func = sm->ancestor_event_handler;
    }
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(StatusLedSm* sm, StatusLedSm_Func desired_state_exit_handler)
{
    while (sm->current_state_exit_handler != desired_state_exit_handler)
    {
        sm->current_state_exit_handler(sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(StatusLedSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = ROOT_exit;
}

static void ROOT_exit(StatusLedSm* sm)
{
    // State machine root is a special case. It cannot be exited. Mark as unused.
    (void)sm;
}

static void ROOT_ChoicePoint_ROUTE__transition(StatusLedSm* sm)
{
    // ROOT.<ChoicePoint>(ROUTE) behavior
    // uml: TransitionTo(ROOT.<ChoicePoint>(ROUTE_BOOT1))
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<ChoicePoint>(ROUTE_BOOT1)`.
        // ROOT.<ChoicePoint>(ROUTE_BOOT1) is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<ChoicePoint>(ROUTE_BOOT1) behavior
        // uml: [IS_STATUS(BOOT1)] TransitionTo(BOOT1)
        if (IS_STATUS(BOOT1))
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `BOOT1`.
            BOOT1_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = StatusLedSm_StateId_BOOT1;
            sm->ancestor_event_handler = NULL;
            return;
        } // end of behavior for ROOT.<ChoicePoint>(ROUTE_BOOT1)
        
        // ROOT.<ChoicePoint>(ROUTE_BOOT1) behavior
        // uml: else TransitionTo(ROOT.<ChoicePoint>(ROUTE_BOOT2))
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ROOT.<ChoicePoint>(ROUTE_BOOT2)`.
            // ROOT.<ChoicePoint>(ROUTE_BOOT2) is a pseudo state and cannot have an `enter` trigger.
            
            // ROOT.<ChoicePoint>(ROUTE_BOOT2) behavior
            // uml: [IS_STATUS(BOOT2)] TransitionTo(BOOT2)
            if (IS_STATUS(BOOT2))
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `BOOT2`.
                BOOT2_enter(sm);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                sm->state_id = StatusLedSm_StateId_BOOT2;
                sm->ancestor_event_handler = NULL;
                return;
            } // end of behavior for ROOT.<ChoicePoint>(ROUTE_BOOT2)
            
            // ROOT.<ChoicePoint>(ROUTE_BOOT2) behavior
            // uml: else TransitionTo(ROOT.<ChoicePoint>(ROUTE_RUNNING_OK))
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `ROOT.<ChoicePoint>(ROUTE_RUNNING_OK)`.
                // ROOT.<ChoicePoint>(ROUTE_RUNNING_OK) is a pseudo state and cannot have an `enter` trigger.
                
                // ROOT.<ChoicePoint>(ROUTE_RUNNING_OK) behavior
                // uml: [IS_STATUS(RUNNING_OK)] TransitionTo(RUNNING_OK)
                if (IS_STATUS(RUNNING_OK))
                {
                    // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                    
                    // Step 2: Transition action: ``.
                    
                    // Step 3: Enter/move towards transition target `RUNNING_OK`.
                    RUNNING_GROUP_enter(sm);
                    RUNNING_OK_enter(sm);
                    
                    // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                    sm->state_id = StatusLedSm_StateId_RUNNING_OK;
                    sm->ancestor_event_handler = NULL;
                    return;
                } // end of behavior for ROOT.<ChoicePoint>(ROUTE_RUNNING_OK)
                
                // ROOT.<ChoicePoint>(ROUTE_RUNNING_OK) behavior
                // uml: else TransitionTo(ROOT.<ChoicePoint>(ROUTE_WARNING))
                {
                    // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                    
                    // Step 2: Transition action: ``.
                    
                    // Step 3: Enter/move towards transition target `ROOT.<ChoicePoint>(ROUTE_WARNING)`.
                    // ROOT.<ChoicePoint>(ROUTE_WARNING) is a pseudo state and cannot have an `enter` trigger.
                    
                    // ROOT.<ChoicePoint>(ROUTE_WARNING) behavior
                    // uml: [IS_STATUS(WARNING)] TransitionTo(WARNING)
                    if (IS_STATUS(WARNING))
                    {
                        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                        
                        // Step 2: Transition action: ``.
                        
                        // Step 3: Enter/move towards transition target `WARNING`.
                        WARNING_enter(sm);
                        
                        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                        sm->state_id = StatusLedSm_StateId_WARNING;
                        sm->ancestor_event_handler = NULL;
                        return;
                    } // end of behavior for ROOT.<ChoicePoint>(ROUTE_WARNING)
                    
                    // ROOT.<ChoicePoint>(ROUTE_WARNING) behavior
                    // uml: else TransitionTo(ROOT.<ChoicePoint>(ROUTE_ERROR))
                    {
                        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                        
                        // Step 2: Transition action: ``.
                        
                        // Step 3: Enter/move towards transition target `ROOT.<ChoicePoint>(ROUTE_ERROR)`.
                        // ROOT.<ChoicePoint>(ROUTE_ERROR) is a pseudo state and cannot have an `enter` trigger.
                        
                        // ROOT.<ChoicePoint>(ROUTE_ERROR) behavior
                        // uml: / { count = 3; } TransitionTo(ERROR_SEQ1)
                        {
                            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                            
                            // Step 2: Transition action: `count = 3;`.
                            count = 3;
                            
                            // Step 3: Enter/move towards transition target `ERROR_SEQ1`.
                            ERROR_SEQ1_enter(sm);
                            
                            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                            sm->state_id = StatusLedSm_StateId_ERROR_SEQ1;
                            sm->ancestor_event_handler = NULL;
                            return;
                        } // end of behavior for ROOT.<ChoicePoint>(ROUTE_ERROR)
                    } // end of behavior for ROOT.<ChoicePoint>(ROUTE_WARNING)
                } // end of behavior for ROOT.<ChoicePoint>(ROUTE_RUNNING_OK)
            } // end of behavior for ROOT.<ChoicePoint>(ROUTE_BOOT2)
        } // end of behavior for ROOT.<ChoicePoint>(ROUTE_BOOT1)
    } // end of behavior for ROOT.<ChoicePoint>(ROUTE)
}

static void ROOT_ChoicePoint_RETURN__transition(StatusLedSm* sm)
{
    // ROOT.<ChoicePoint>(RETURN) behavior
    // uml: TransitionTo(ROOT.<ChoicePoint>(ROUTE))
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<ChoicePoint>(ROUTE)`.
        // ROOT.<ChoicePoint>(ROUTE) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        ROOT_ChoicePoint_ROUTE__transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for ROOT.<ChoicePoint>(RETURN)
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state BOOT1
////////////////////////////////////////////////////////////////////////////////

static void BOOT1_enter(StatusLedSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = BOOT1_exit;
    sm->current_event_handlers[StatusLedSm_EventId_DO] = BOOT1_do;
    
    // BOOT1 behavior
    // uml: enter / { ramp_init_up(); }
    {
        // Step 1: execute action `ramp_init_up();`
        ramp_init_up();
    } // end of behavior for BOOT1
}

static void BOOT1_exit(StatusLedSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[StatusLedSm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void BOOT1_do(StatusLedSm* sm)
{
    // No ancestor state handles `do` event.
    
    // BOOT1 behavior
    // uml: do / { ramp_up(FAST); }
    {
        // Step 1: execute action `ramp_up(FAST);`
        ramp_up(FAST);
        
        // Step 2: determine if ancestor gets to handle event next.
        // Don't consume special `do` event.
    } // end of behavior for BOOT1
    
    // BOOT1 behavior
    // uml: do [is_ramp_done()] TransitionTo(ROOT.<ChoicePoint>(RETURN))
    if (is_ramp_done())
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        BOOT1_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<ChoicePoint>(RETURN)`.
        // ROOT.<ChoicePoint>(RETURN) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        ROOT_ChoicePoint_RETURN__transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for BOOT1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state BOOT2
////////////////////////////////////////////////////////////////////////////////

static void BOOT2_enter(StatusLedSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = BOOT2_exit;
    sm->current_event_handlers[StatusLedSm_EventId_DO] = BOOT2_do;
    
    // BOOT2 behavior
    // uml: enter / { ramp_init_up(); }
    {
        // Step 1: execute action `ramp_init_up();`
        ramp_init_up();
    } // end of behavior for BOOT2
}

static void BOOT2_exit(StatusLedSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[StatusLedSm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void BOOT2_do(StatusLedSm* sm)
{
    // No ancestor state handles `do` event.
    
    // BOOT2 behavior
    // uml: do / { ramp_up(MEDIUM); }
    {
        // Step 1: execute action `ramp_up(MEDIUM);`
        ramp_up(MEDIUM);
        
        // Step 2: determine if ancestor gets to handle event next.
        // Don't consume special `do` event.
    } // end of behavior for BOOT2
    
    // BOOT2 behavior
    // uml: do [is_ramp_done()] TransitionTo(ROOT.<ChoicePoint>(RETURN))
    if (is_ramp_done())
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        BOOT2_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<ChoicePoint>(RETURN)`.
        // ROOT.<ChoicePoint>(RETURN) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        ROOT_ChoicePoint_RETURN__transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for BOOT2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ERROR_SEQ1
////////////////////////////////////////////////////////////////////////////////

static void ERROR_SEQ1_enter(StatusLedSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = ERROR_SEQ1_exit;
    sm->current_event_handlers[StatusLedSm_EventId_DO] = ERROR_SEQ1_do;
    
    // ERROR_SEQ1 behavior
    // uml: enter / { timer_reset(); }
    {
        // Step 1: execute action `timer_reset();`
        timer_reset();
    } // end of behavior for ERROR_SEQ1
    
    // ERROR_SEQ1 behavior
    // uml: enter / { set_led_duty(0); }
    {
        // Step 1: execute action `set_led_duty(0);`
        set_led_duty(0);
    } // end of behavior for ERROR_SEQ1
}

static void ERROR_SEQ1_exit(StatusLedSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[StatusLedSm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void ERROR_SEQ1_do(StatusLedSm* sm)
{
    // No ancestor state handles `do` event.
    
    // ERROR_SEQ1 behavior
    // uml: do [timer_get_ms() >= 100] TransitionTo(ERROR_SEQ2)
    if (timer_get_ms() >= 100)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        ERROR_SEQ1_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ERROR_SEQ2`.
        ERROR_SEQ2_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = StatusLedSm_StateId_ERROR_SEQ2;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for ERROR_SEQ1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ERROR_SEQ2
////////////////////////////////////////////////////////////////////////////////

static void ERROR_SEQ2_enter(StatusLedSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = ERROR_SEQ2_exit;
    sm->current_event_handlers[StatusLedSm_EventId_DO] = ERROR_SEQ2_do;
    
    // ERROR_SEQ2 behavior
    // uml: enter / { timer_reset(); }
    {
        // Step 1: execute action `timer_reset();`
        timer_reset();
    } // end of behavior for ERROR_SEQ2
    
    // ERROR_SEQ2 behavior
    // uml: enter / { set_led_duty(255); }
    {
        // Step 1: execute action `set_led_duty(255);`
        set_led_duty(255);
    } // end of behavior for ERROR_SEQ2
}

static void ERROR_SEQ2_exit(StatusLedSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[StatusLedSm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void ERROR_SEQ2_do(StatusLedSm* sm)
{
    // No ancestor state handles `do` event.
    
    // ERROR_SEQ2 behavior
    // uml: do [timer_get_ms() >= 100] / { count--; } TransitionTo(ROOT.<ChoicePoint>(ERROR_CHOICE))
    if (timer_get_ms() >= 100)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        ERROR_SEQ2_exit(sm);
        
        // Step 2: Transition action: `count--;`.
        count--;
        
        // Step 3: Enter/move towards transition target `ROOT.<ChoicePoint>(ERROR_CHOICE)`.
        // ROOT.<ChoicePoint>(ERROR_CHOICE) is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<ChoicePoint>(ERROR_CHOICE) behavior
        // uml: [count > 0] TransitionTo(ERROR_SEQ1)
        if (count > 0)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ERROR_SEQ1`.
            ERROR_SEQ1_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = StatusLedSm_StateId_ERROR_SEQ1;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for ROOT.<ChoicePoint>(ERROR_CHOICE)
        
        // ROOT.<ChoicePoint>(ERROR_CHOICE) behavior
        // uml: else TransitionTo(ERROR_SEQ3)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ERROR_SEQ3`.
            ERROR_SEQ3_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = StatusLedSm_StateId_ERROR_SEQ3;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for ROOT.<ChoicePoint>(ERROR_CHOICE)
    } // end of behavior for ERROR_SEQ2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ERROR_SEQ3
////////////////////////////////////////////////////////////////////////////////

static void ERROR_SEQ3_enter(StatusLedSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = ERROR_SEQ3_exit;
    sm->current_event_handlers[StatusLedSm_EventId_DO] = ERROR_SEQ3_do;
    
    // ERROR_SEQ3 behavior
    // uml: enter / { set_led_duty(0); }
    {
        // Step 1: execute action `set_led_duty(0);`
        set_led_duty(0);
    } // end of behavior for ERROR_SEQ3
    
    // ERROR_SEQ3 behavior
    // uml: enter / { timer_reset(); }
    {
        // Step 1: execute action `timer_reset();`
        timer_reset();
    } // end of behavior for ERROR_SEQ3
}

static void ERROR_SEQ3_exit(StatusLedSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[StatusLedSm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void ERROR_SEQ3_do(StatusLedSm* sm)
{
    // No ancestor state handles `do` event.
    
    // ERROR_SEQ3 behavior
    // uml: do [timer_get_ms() >= 1000] TransitionTo(ROOT.<ChoicePoint>(RETURN))
    if (timer_get_ms() >= 1000)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        ERROR_SEQ3_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<ChoicePoint>(RETURN)`.
        // ROOT.<ChoicePoint>(RETURN) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        ROOT_ChoicePoint_RETURN__transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for ERROR_SEQ3
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state RUNNING_GROUP
////////////////////////////////////////////////////////////////////////////////

static void RUNNING_GROUP_enter(StatusLedSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = RUNNING_GROUP_exit;
    
    // RUNNING_GROUP behavior
    // uml: enter / { _ramp_bottom = 25; }
    {
        // Step 1: execute action `_ramp_bottom = 25;`
        _ramp_bottom = 25;
    } // end of behavior for RUNNING_GROUP
}

static void RUNNING_GROUP_exit(StatusLedSm* sm)
{
    // RUNNING_GROUP behavior
    // uml: exit / { _ramp_bottom = 0; }
    {
        // Step 1: execute action `_ramp_bottom = 0;`
        _ramp_bottom = 0;
    } // end of behavior for RUNNING_GROUP
    
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state RUNNING_OK
////////////////////////////////////////////////////////////////////////////////

static void RUNNING_OK_enter(StatusLedSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = RUNNING_OK_exit;
    sm->current_event_handlers[StatusLedSm_EventId_DO] = RUNNING_OK_do;
    
    // RUNNING_OK behavior
    // uml: enter / { ramp_init_up(); }
    {
        // Step 1: execute action `ramp_init_up();`
        ramp_init_up();
    } // end of behavior for RUNNING_OK
}

static void RUNNING_OK_exit(StatusLedSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = RUNNING_GROUP_exit;
    sm->current_event_handlers[StatusLedSm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void RUNNING_OK_do(StatusLedSm* sm)
{
    // No ancestor state handles `do` event.
    
    // RUNNING_OK behavior
    // uml: do / { ramp_up(SLOW); }
    {
        // Step 1: execute action `ramp_up(SLOW);`
        ramp_up(SLOW);
        
        // Step 2: determine if ancestor gets to handle event next.
        // Don't consume special `do` event.
    } // end of behavior for RUNNING_OK
    
    // RUNNING_OK behavior
    // uml: do [is_ramp_done()] TransitionTo(RUNNING_OK_SEQ2)
    if (is_ramp_done())
    {
        // Step 1: Exit states until we reach `RUNNING_GROUP` state (Least Common Ancestor for transition).
        RUNNING_OK_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RUNNING_OK_SEQ2`.
        RUNNING_OK_SEQ2_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = StatusLedSm_StateId_RUNNING_OK_SEQ2;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for RUNNING_OK
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state RUNNING_OK_SEQ2
////////////////////////////////////////////////////////////////////////////////

static void RUNNING_OK_SEQ2_enter(StatusLedSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = RUNNING_OK_SEQ2_exit;
    sm->current_event_handlers[StatusLedSm_EventId_DO] = RUNNING_OK_SEQ2_do;
    
    // RUNNING_OK_SEQ2 behavior
    // uml: enter / { ramp_init_down(); }
    {
        // Step 1: execute action `ramp_init_down();`
        ramp_init_down();
    } // end of behavior for RUNNING_OK_SEQ2
}

static void RUNNING_OK_SEQ2_exit(StatusLedSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = RUNNING_GROUP_exit;
    sm->current_event_handlers[StatusLedSm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void RUNNING_OK_SEQ2_do(StatusLedSm* sm)
{
    // No ancestor state handles `do` event.
    
    // RUNNING_OK_SEQ2 behavior
    // uml: do / { ramp_down(SLOW); }
    {
        // Step 1: execute action `ramp_down(SLOW);`
        ramp_down(SLOW);
        
        // Step 2: determine if ancestor gets to handle event next.
        // Don't consume special `do` event.
    } // end of behavior for RUNNING_OK_SEQ2
    
    // RUNNING_OK_SEQ2 behavior
    // uml: do [is_ramp_done()] TransitionTo(ROOT.<ChoicePoint>(RETURN))
    if (is_ramp_done())
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<ChoicePoint>(RETURN)`.
        // ROOT.<ChoicePoint>(RETURN) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        ROOT_ChoicePoint_RETURN__transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for RUNNING_OK_SEQ2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state WARNING
////////////////////////////////////////////////////////////////////////////////

static void WARNING_enter(StatusLedSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = WARNING_exit;
    sm->current_event_handlers[StatusLedSm_EventId_DO] = WARNING_do;
    
    // WARNING behavior
    // uml: enter / { ramp_init_down(); }
    {
        // Step 1: execute action `ramp_init_down();`
        ramp_init_down();
    } // end of behavior for WARNING
}

static void WARNING_exit(StatusLedSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[StatusLedSm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void WARNING_do(StatusLedSm* sm)
{
    // No ancestor state handles `do` event.
    
    // WARNING behavior
    // uml: do / { ramp_down(MEDIUM); }
    {
        // Step 1: execute action `ramp_down(MEDIUM);`
        ramp_down(MEDIUM);
        
        // Step 2: determine if ancestor gets to handle event next.
        // Don't consume special `do` event.
    } // end of behavior for WARNING
    
    // WARNING behavior
    // uml: do [is_ramp_done()] TransitionTo(WARNING_SEQ2)
    if (is_ramp_done())
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        WARNING_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WARNING_SEQ2`.
        WARNING_SEQ2_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = StatusLedSm_StateId_WARNING_SEQ2;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for WARNING
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state WARNING_SEQ2
////////////////////////////////////////////////////////////////////////////////

static void WARNING_SEQ2_enter(StatusLedSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = WARNING_SEQ2_exit;
    sm->current_event_handlers[StatusLedSm_EventId_DO] = WARNING_SEQ2_do;
    
    // WARNING_SEQ2 behavior
    // uml: enter / { timer_reset(); }
    {
        // Step 1: execute action `timer_reset();`
        timer_reset();
    } // end of behavior for WARNING_SEQ2
    
    // WARNING_SEQ2 behavior
    // uml: enter / { set_led_duty(0); }
    {
        // Step 1: execute action `set_led_duty(0);`
        set_led_duty(0);
    } // end of behavior for WARNING_SEQ2
}

static void WARNING_SEQ2_exit(StatusLedSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[StatusLedSm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void WARNING_SEQ2_do(StatusLedSm* sm)
{
    // No ancestor state handles `do` event.
    
    // WARNING_SEQ2 behavior
    // uml: do [timer_get_ms() >= 500] TransitionTo(ROOT.<ChoicePoint>(RETURN))
    if (timer_get_ms() >= 500)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        WARNING_SEQ2_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<ChoicePoint>(RETURN)`.
        // ROOT.<ChoicePoint>(RETURN) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        ROOT_ChoicePoint_RETURN__transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for WARNING_SEQ2
}

// Thread safe.
char const * StatusLedSm_state_id_to_string(StatusLedSm_StateId id)
{
    switch (id)
    {
        case StatusLedSm_StateId_ROOT: return "ROOT";
        case StatusLedSm_StateId_BOOT1: return "BOOT1";
        case StatusLedSm_StateId_BOOT2: return "BOOT2";
        case StatusLedSm_StateId_ERROR_SEQ1: return "ERROR_SEQ1";
        case StatusLedSm_StateId_ERROR_SEQ2: return "ERROR_SEQ2";
        case StatusLedSm_StateId_ERROR_SEQ3: return "ERROR_SEQ3";
        case StatusLedSm_StateId_RUNNING_GROUP: return "RUNNING_GROUP";
        case StatusLedSm_StateId_RUNNING_OK: return "RUNNING_OK";
        case StatusLedSm_StateId_RUNNING_OK_SEQ2: return "RUNNING_OK_SEQ2";
        case StatusLedSm_StateId_WARNING: return "WARNING";
        case StatusLedSm_StateId_WARNING_SEQ2: return "WARNING_SEQ2";
        default: return "?";
    }
}

// Thread safe.
char const * StatusLedSm_event_id_to_string(StatusLedSm_EventId id)
{
    switch (id)
    {
        case StatusLedSm_EventId_DO: return "DO";
        default: return "?";
    }
}
