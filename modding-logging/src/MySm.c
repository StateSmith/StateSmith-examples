// Autogenerated with StateSmith
#include "MySm.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

static void ROOT_enter(MySm* self);
static void ROOT_exit(MySm* self);

static void ORDER_MENU_enter(MySm* self);
static void ORDER_MENU_exit(MySm* self);
static void ORDER_MENU_ev3(MySm* self);

static void BEVERAGE_enter(MySm* self);
static void BEVERAGE_exit(MySm* self);
static void BEVERAGE_ev2(MySm* self);

static void COFFEE_enter(MySm* self);
static void COFFEE_exit(MySm* self);
static void COFFEE_ev1(MySm* self);

static void TEA_enter(MySm* self);
static void TEA_exit(MySm* self);
static void TEA_ev1(MySm* self);

static void WATER_enter(MySm* self);
static void WATER_exit(MySm* self);
static void WATER_ev1(MySm* self);

static void FOOD_enter(MySm* self);
static void FOOD_exit(MySm* self);
static void FOOD_ev2(MySm* self);

static void JUNK_enter(MySm* self);
static void JUNK_exit(MySm* self);
static void JUNK_ev1(MySm* self);

static void POTATO_enter(MySm* self);
static void POTATO_exit(MySm* self);
static void POTATO_ev1(MySm* self);

static void SUSHI_enter(MySm* self);
static void SUSHI_exit(MySm* self);
static void SUSHI_ev1(MySm* self);

static void WAITING_enter(MySm* self);
static void WAITING_exit(MySm* self);
static void WAITING_ev3(MySm* self);

// This function is used when StateSmith doesn't know what the active leaf state is at compile time due to sub states
// or when multiple states need to be exited.
static void exit_up_to_state_handler(MySm* self, const MySm_Func desired_state_exit_handler);

static void BEVERAGE_InitialState_transition(MySm* self);


void MySm_ctor(MySm* self)
{
    memset(self, 0, sizeof(*self));
}

static void exit_up_to_state_handler(MySm* self, const MySm_Func desired_state_exit_handler)
{
    while (self->current_state_exit_handler != desired_state_exit_handler)
    {
        self->current_state_exit_handler(self);
    }
}

void MySm_start(MySm* self)
{
    ROOT_enter(self);
    // ROOT behavior
    // uml: TransitionTo(ROOT.InitialState)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.InitialState`.
        // ROOT.InitialState is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.InitialState behavior
        // uml: TransitionTo(WAITING)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `WAITING`.
            WAITING_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = MySm_StateId_WAITING;
            // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
            return;
        } // end of behavior for ROOT.InitialState
    } // end of behavior for ROOT
}

void MySm_dispatch_event(MySm* self, enum MySm_EventId event_id)
{
    MySm_Func behavior_func = self->current_event_handlers[event_id];
    
    while (behavior_func != NULL)
    {
        self->ancestor_event_handler = NULL;
        behavior_func(self);
        behavior_func = self->ancestor_event_handler;
    }
}

const char* MySm_state_id_to_string(const enum MySm_StateId id)
{
    switch (id)
    {
        case MySm_StateId_ROOT: return "ROOT";
        case MySm_StateId_ORDER_MENU: return "ORDER_MENU";
        case MySm_StateId_BEVERAGE: return "BEVERAGE";
        case MySm_StateId_COFFEE: return "COFFEE";
        case MySm_StateId_TEA: return "TEA";
        case MySm_StateId_WATER: return "WATER";
        case MySm_StateId_FOOD: return "FOOD";
        case MySm_StateId_JUNK: return "JUNK";
        case MySm_StateId_POTATO: return "POTATO";
        case MySm_StateId_SUSHI: return "SUSHI";
        case MySm_StateId_WAITING: return "WAITING";
        default: return "?";
    }
}

////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = ROOT_exit;
}

static void ROOT_exit(MySm* self)
{
    // State machine root is a special case. It cannot be exited.
    (void)self;  // nothing to see here compiler. move along!
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ORDER_MENU
////////////////////////////////////////////////////////////////////////////////

static void ORDER_MENU_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = ORDER_MENU_exit;
    self->current_event_handlers[MySm_EventId_EV3] = ORDER_MENU_ev3;
}

static void ORDER_MENU_exit(MySm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
    self->current_event_handlers[MySm_EventId_EV3] = NULL;  // no ancestor listens to this event
}

static void ORDER_MENU_ev3(MySm* self)
{
    // No ancestor state handles `EV3` event.
    
    // ORDER_MENU behavior
    // uml: EV3 TransitionTo(WAITING)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WAITING`.
        WAITING_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = MySm_StateId_WAITING;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for ORDER_MENU
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state BEVERAGE
////////////////////////////////////////////////////////////////////////////////

static void BEVERAGE_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = BEVERAGE_exit;
    self->current_event_handlers[MySm_EventId_EV2] = BEVERAGE_ev2;
    
    // BEVERAGE behavior
    // uml: enter / { printf("Entered BEVERAGE."); }
    {
        // Step 1: execute action `printf("Entered BEVERAGE.");`
        printf("Entered BEVERAGE.");
    } // end of behavior for BEVERAGE
}

static void BEVERAGE_exit(MySm* self)
{
    // BEVERAGE behavior
    // uml: exit / { printf("Exited BEVERAGE."); }
    {
        // Step 1: execute action `printf("Exited BEVERAGE.");`
        printf("Exited BEVERAGE.");
    } // end of behavior for BEVERAGE
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ORDER_MENU_exit;
    self->current_event_handlers[MySm_EventId_EV2] = NULL;  // no ancestor listens to this event
}

static void BEVERAGE_ev2(MySm* self)
{
    // No ancestor state handles `EV2` event.
    
    // BEVERAGE behavior
    // uml: EV2 TransitionTo(FOOD)
    {
        // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, ORDER_MENU_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `FOOD`.
        FOOD_enter(self);
        
        // FOOD.InitialState behavior
        // uml: TransitionTo(JUNK)
        {
            // Step 1: Exit states until we reach `FOOD` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `JUNK`.
            JUNK_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = MySm_StateId_JUNK;
            // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
            return;
        } // end of behavior for FOOD.InitialState
    } // end of behavior for BEVERAGE
}

static void BEVERAGE_InitialState_transition(MySm* self)
{
    // BEVERAGE.InitialState behavior
    // uml: TransitionTo(WATER)
    {
        // Step 1: Exit states until we reach `BEVERAGE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WATER`.
        WATER_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = MySm_StateId_WATER;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for BEVERAGE.InitialState
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state COFFEE
////////////////////////////////////////////////////////////////////////////////

static void COFFEE_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = COFFEE_exit;
    self->current_event_handlers[MySm_EventId_EV1] = COFFEE_ev1;
    
    // COFFEE behavior
    // uml: enter / { printf("Entered COFFEE."); }
    {
        // Step 1: execute action `printf("Entered COFFEE.");`
        printf("Entered COFFEE.");
    } // end of behavior for COFFEE
}

static void COFFEE_exit(MySm* self)
{
    // COFFEE behavior
    // uml: exit / { printf("Exited COFFEE."); }
    {
        // Step 1: execute action `printf("Exited COFFEE.");`
        printf("Exited COFFEE.");
    } // end of behavior for COFFEE
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = BEVERAGE_exit;
    self->current_event_handlers[MySm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void COFFEE_ev1(MySm* self)
{
    // No ancestor state handles `EV1` event.
    
    // COFFEE behavior
    // uml: EV1 TransitionTo(TEA)
    {
        // Step 1: Exit states until we reach `BEVERAGE` state (Least Common Ancestor for transition).
        COFFEE_exit(self);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `TEA`.
        TEA_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = MySm_StateId_TEA;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for COFFEE
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEA
////////////////////////////////////////////////////////////////////////////////

static void TEA_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEA_exit;
    self->current_event_handlers[MySm_EventId_EV1] = TEA_ev1;
    
    // TEA behavior
    // uml: enter / { printf("Entered TEA."); }
    {
        // Step 1: execute action `printf("Entered TEA.");`
        printf("Entered TEA.");
    } // end of behavior for TEA
}

static void TEA_exit(MySm* self)
{
    // TEA behavior
    // uml: exit / { printf("Exited TEA."); }
    {
        // Step 1: execute action `printf("Exited TEA.");`
        printf("Exited TEA.");
    } // end of behavior for TEA
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = BEVERAGE_exit;
    self->current_event_handlers[MySm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEA_ev1(MySm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEA behavior
    // uml: EV1 TransitionTo(WATER)
    {
        // Step 1: Exit states until we reach `BEVERAGE` state (Least Common Ancestor for transition).
        TEA_exit(self);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WATER`.
        WATER_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = MySm_StateId_WATER;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEA
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state WATER
////////////////////////////////////////////////////////////////////////////////

static void WATER_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = WATER_exit;
    self->current_event_handlers[MySm_EventId_EV1] = WATER_ev1;
}

static void WATER_exit(MySm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = BEVERAGE_exit;
    self->current_event_handlers[MySm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void WATER_ev1(MySm* self)
{
    // No ancestor state handles `EV1` event.
    
    // WATER behavior
    // uml: EV1 TransitionTo(COFFEE)
    {
        // Step 1: Exit states until we reach `BEVERAGE` state (Least Common Ancestor for transition).
        WATER_exit(self);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `COFFEE`.
        COFFEE_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = MySm_StateId_COFFEE;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for WATER
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state FOOD
////////////////////////////////////////////////////////////////////////////////

static void FOOD_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = FOOD_exit;
    self->current_event_handlers[MySm_EventId_EV2] = FOOD_ev2;
    
    // FOOD behavior
    // uml: enter / { printf("Entered FOOD."); }
    {
        // Step 1: execute action `printf("Entered FOOD.");`
        printf("Entered FOOD.");
    } // end of behavior for FOOD
}

static void FOOD_exit(MySm* self)
{
    // FOOD behavior
    // uml: exit / { printf("Exited FOOD."); }
    {
        // Step 1: execute action `printf("Exited FOOD.");`
        printf("Exited FOOD.");
    } // end of behavior for FOOD
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ORDER_MENU_exit;
    self->current_event_handlers[MySm_EventId_EV2] = NULL;  // no ancestor listens to this event
}

static void FOOD_ev2(MySm* self)
{
    // No ancestor state handles `EV2` event.
    
    // FOOD behavior
    // uml: EV2 TransitionTo(BEVERAGE)
    {
        // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, ORDER_MENU_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `BEVERAGE`.
        BEVERAGE_enter(self);
        
        // Finish transition by calling pseudo state transition function.
        BEVERAGE_InitialState_transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for FOOD
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state JUNK
////////////////////////////////////////////////////////////////////////////////

static void JUNK_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = JUNK_exit;
    self->current_event_handlers[MySm_EventId_EV1] = JUNK_ev1;
    
    // JUNK behavior
    // uml: enter / { printf("Entered JUNK."); }
    {
        // Step 1: execute action `printf("Entered JUNK.");`
        printf("Entered JUNK.");
    } // end of behavior for JUNK
}

static void JUNK_exit(MySm* self)
{
    // JUNK behavior
    // uml: exit / { printf("Exited JUNK."); }
    {
        // Step 1: execute action `printf("Exited JUNK.");`
        printf("Exited JUNK.");
    } // end of behavior for JUNK
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = FOOD_exit;
    self->current_event_handlers[MySm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void JUNK_ev1(MySm* self)
{
    // No ancestor state handles `EV1` event.
    
    // JUNK behavior
    // uml: EV1 TransitionTo(POTATO)
    {
        // Step 1: Exit states until we reach `FOOD` state (Least Common Ancestor for transition).
        JUNK_exit(self);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `POTATO`.
        POTATO_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = MySm_StateId_POTATO;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for JUNK
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state POTATO
////////////////////////////////////////////////////////////////////////////////

static void POTATO_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = POTATO_exit;
    self->current_event_handlers[MySm_EventId_EV1] = POTATO_ev1;
    
    // POTATO behavior
    // uml: enter / { printf("Entered POTATO."); }
    {
        // Step 1: execute action `printf("Entered POTATO.");`
        printf("Entered POTATO.");
    } // end of behavior for POTATO
}

static void POTATO_exit(MySm* self)
{
    // POTATO behavior
    // uml: exit / { printf("Exited POTATO."); }
    {
        // Step 1: execute action `printf("Exited POTATO.");`
        printf("Exited POTATO.");
    } // end of behavior for POTATO
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = FOOD_exit;
    self->current_event_handlers[MySm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void POTATO_ev1(MySm* self)
{
    // No ancestor state handles `EV1` event.
    
    // POTATO behavior
    // uml: EV1 TransitionTo(SUSHI)
    {
        // Step 1: Exit states until we reach `FOOD` state (Least Common Ancestor for transition).
        POTATO_exit(self);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `SUSHI`.
        SUSHI_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = MySm_StateId_SUSHI;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for POTATO
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SUSHI
////////////////////////////////////////////////////////////////////////////////

static void SUSHI_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = SUSHI_exit;
    self->current_event_handlers[MySm_EventId_EV1] = SUSHI_ev1;
    
    // SUSHI behavior
    // uml: enter / { printf("Entered SUSHI."); }
    {
        // Step 1: execute action `printf("Entered SUSHI.");`
        printf("Entered SUSHI.");
    } // end of behavior for SUSHI
}

static void SUSHI_exit(MySm* self)
{
    // SUSHI behavior
    // uml: exit / { printf("Exited SUSHI."); }
    {
        // Step 1: execute action `printf("Exited SUSHI.");`
        printf("Exited SUSHI.");
    } // end of behavior for SUSHI
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = FOOD_exit;
    self->current_event_handlers[MySm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void SUSHI_ev1(MySm* self)
{
    // No ancestor state handles `EV1` event.
    
    // SUSHI behavior
    // uml: EV1 TransitionTo(JUNK)
    {
        // Step 1: Exit states until we reach `FOOD` state (Least Common Ancestor for transition).
        SUSHI_exit(self);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `JUNK`.
        JUNK_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = MySm_StateId_JUNK;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for SUSHI
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state WAITING
////////////////////////////////////////////////////////////////////////////////

static void WAITING_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = WAITING_exit;
    self->current_event_handlers[MySm_EventId_EV3] = WAITING_ev3;
}

static void WAITING_exit(MySm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
    self->current_event_handlers[MySm_EventId_EV3] = NULL;  // no ancestor listens to this event
}

static void WAITING_ev3(MySm* self)
{
    // No ancestor state handles `EV3` event.
    
    // WAITING behavior
    // uml: EV3 TransitionTo(ORDER_MENU)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        WAITING_exit(self);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ORDER_MENU`.
        ORDER_MENU_enter(self);
        
        // ORDER_MENU.InitialState behavior
        // uml: TransitionTo(BEVERAGE)
        {
            // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `BEVERAGE`.
            BEVERAGE_enter(self);
            
            // Finish transition by calling pseudo state transition function.
            BEVERAGE_InitialState_transition(self);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ORDER_MENU.InitialState
    } // end of behavior for WAITING
}


