// Autogenerated with StateSmith
#include "MySm.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

static void ROOT_enter(MySm* self);
static void ROOT_exit(MySm* self);

static void ORDER_MENU_enter(MySm* self);
static void ORDER_MENU_exit(MySm* self);
static void ORDER_MENU_ev3(MySm* self);

static void OM__BEVERAGE_enter(MySm* self);
static void OM__BEVERAGE_exit(MySm* self);
static void OM__BEVERAGE_ev2(MySm* self);

static void OM__BEV__NONE_enter(MySm* self);
static void OM__BEV__NONE_exit(MySm* self);
static void OM__BEV__NONE_ev1(MySm* self);

static void OM__BEV__TEA_enter(MySm* self);
static void OM__BEV__TEA_exit(MySm* self);
static void OM__BEV__TEA_ev1(MySm* self);

static void OM__BEV__WATER_enter(MySm* self);
static void OM__BEV__WATER_exit(MySm* self);
static void OM__BEV__WATER_ev1(MySm* self);

static void OM__DESERT_enter(MySm* self);
static void OM__DESERT_exit(MySm* self);
static void OM__DESERT_ev3(MySm* self);

static void DSRT__CAKE_enter(MySm* self);
static void DSRT__CAKE_exit(MySm* self);

static void OM__FOOD_enter(MySm* self);
static void OM__FOOD_exit(MySm* self);
static void OM__FOOD_ev2(MySm* self);
static void OM__FOOD_ev3(MySm* self);

static void OM__FOOD__NONE_enter(MySm* self);
static void OM__FOOD__NONE_exit(MySm* self);
static void OM__FOOD__NONE_ev1(MySm* self);

static void OM__FOOD__POTATO_enter(MySm* self);
static void OM__FOOD__POTATO_exit(MySm* self);
static void OM__FOOD__POTATO_ev1(MySm* self);

static void OM__FOOD__SUSHI_enter(MySm* self);
static void OM__FOOD__SUSHI_exit(MySm* self);
static void OM__FOOD__SUSHI_ev1(MySm* self);

static void WAITING_enter(MySm* self);
static void WAITING_exit(MySm* self);
static void WAITING_ev3(MySm* self);

// This function is used when StateSmith doesn't know what the active leaf state is at compile time due to sub states
// or when multiple states need to be exited.
static void exit_up_to_state_handler(MySm* self, const MySm_Func desired_state_exit_handler);

static void OM__BEVERAGE_InitialState_transition(MySm* self);

static void OM__FOOD_InitialState_transition(MySm* self);


void MySm_ctor(MySm* self)
{
    memset(self, 0, sizeof(*self));
}

static void exit_up_to_state_handler(MySm* self, const MySm_Func desired_state_exit_handler)
{
    while (self->current_state_exit_handler != desired_state_exit_handler)
    {
        self->current_state_exit_handler(self);
    }
}

void MySm_start(MySm* self)
{
    ROOT_enter(self);
    // ROOT behavior
    // uml: TransitionTo(ROOT.InitialState)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.InitialState`.
        // ROOT.InitialState is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.InitialState behavior
        // uml: TransitionTo(WAITING)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `WAITING`.
            WAITING_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = MySm_StateId_WAITING;
            // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
            return;
        } // end of behavior for ROOT.InitialState
    } // end of behavior for ROOT
}

void MySm_dispatch_event(MySm* self, enum MySm_EventId event_id)
{
    MySm_Func behavior_func = self->current_event_handlers[event_id];
    
    while (behavior_func != NULL)
    {
        self->ancestor_event_handler = NULL;
        behavior_func(self);
        behavior_func = self->ancestor_event_handler;
    }
}

const char* MySm_state_id_to_string(const enum MySm_StateId id)
{
    switch (id)
    {
        case MySm_StateId_ROOT: return "ROOT";
        case MySm_StateId_ORDER_MENU: return "ORDER_MENU";
        case MySm_StateId_OM__BEVERAGE: return "OM__BEVERAGE";
        case MySm_StateId_OM__BEV__NONE: return "OM__BEV__NONE";
        case MySm_StateId_OM__BEV__TEA: return "OM__BEV__TEA";
        case MySm_StateId_OM__BEV__WATER: return "OM__BEV__WATER";
        case MySm_StateId_OM__DESERT: return "OM__DESERT";
        case MySm_StateId_DSRT__CAKE: return "DSRT__CAKE";
        case MySm_StateId_OM__FOOD: return "OM__FOOD";
        case MySm_StateId_OM__FOOD__NONE: return "OM__FOOD__NONE";
        case MySm_StateId_OM__FOOD__POTATO: return "OM__FOOD__POTATO";
        case MySm_StateId_OM__FOOD__SUSHI: return "OM__FOOD__SUSHI";
        case MySm_StateId_WAITING: return "WAITING";
        default: return "?";
    }
}

////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = ROOT_exit;
}

static void ROOT_exit(MySm* self)
{
    // State machine root is a special case. It cannot be exited.
    (void)self;  // nothing to see here compiler. move along!
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ORDER_MENU
////////////////////////////////////////////////////////////////////////////////

static void ORDER_MENU_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = ORDER_MENU_exit;
    self->current_event_handlers[MySm_EventId_EV3] = ORDER_MENU_ev3;
}

static void ORDER_MENU_exit(MySm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
    self->current_event_handlers[MySm_EventId_EV3] = NULL;  // no ancestor listens to this event
}

static void ORDER_MENU_ev3(MySm* self)
{
    // No ancestor state handles `EV3` event.
    
    // ORDER_MENU behavior
    // uml: EV3 TransitionTo(WAITING)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WAITING`.
        WAITING_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = MySm_StateId_WAITING;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for ORDER_MENU
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state OM__BEVERAGE
////////////////////////////////////////////////////////////////////////////////

static void OM__BEVERAGE_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = OM__BEVERAGE_exit;
    self->current_event_handlers[MySm_EventId_EV2] = OM__BEVERAGE_ev2;
}

static void OM__BEVERAGE_exit(MySm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ORDER_MENU_exit;
    self->current_event_handlers[MySm_EventId_EV2] = NULL;  // no ancestor listens to this event
}

static void OM__BEVERAGE_ev2(MySm* self)
{
    // No ancestor state handles `EV2` event.
    
    // OM__BEVERAGE behavior
    // uml: EV2 TransitionTo(OM__FOOD)
    {
        // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, ORDER_MENU_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `OM__FOOD`.
        OM__FOOD_enter(self);
        
        // Finish transition by calling pseudo state transition function.
        OM__FOOD_InitialState_transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for OM__BEVERAGE
}

static void OM__BEVERAGE_InitialState_transition(MySm* self)
{
    // OM__BEVERAGE.InitialState behavior
    // uml: TransitionTo(OM__BEV__NONE)
    {
        // Step 1: Exit states until we reach `OM__BEVERAGE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `OM__BEV__NONE`.
        OM__BEV__NONE_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = MySm_StateId_OM__BEV__NONE;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for OM__BEVERAGE.InitialState
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state OM__BEV__NONE
////////////////////////////////////////////////////////////////////////////////

static void OM__BEV__NONE_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = OM__BEV__NONE_exit;
    self->current_event_handlers[MySm_EventId_EV1] = OM__BEV__NONE_ev1;
}

static void OM__BEV__NONE_exit(MySm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = OM__BEVERAGE_exit;
    self->current_event_handlers[MySm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void OM__BEV__NONE_ev1(MySm* self)
{
    // No ancestor state handles `EV1` event.
    
    // OM__BEV__NONE behavior
    // uml: EV1 TransitionTo(OM__BEV__WATER)
    {
        // Step 1: Exit states until we reach `OM__BEVERAGE` state (Least Common Ancestor for transition).
        OM__BEV__NONE_exit(self);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `OM__BEV__WATER`.
        OM__BEV__WATER_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = MySm_StateId_OM__BEV__WATER;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for OM__BEV__NONE
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state OM__BEV__TEA
////////////////////////////////////////////////////////////////////////////////

static void OM__BEV__TEA_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = OM__BEV__TEA_exit;
    self->current_event_handlers[MySm_EventId_EV1] = OM__BEV__TEA_ev1;
}

static void OM__BEV__TEA_exit(MySm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = OM__BEVERAGE_exit;
    self->current_event_handlers[MySm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void OM__BEV__TEA_ev1(MySm* self)
{
    // No ancestor state handles `EV1` event.
    
    // OM__BEV__TEA behavior
    // uml: EV1 TransitionTo(OM__BEV__NONE)
    {
        // Step 1: Exit states until we reach `OM__BEVERAGE` state (Least Common Ancestor for transition).
        OM__BEV__TEA_exit(self);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `OM__BEV__NONE`.
        OM__BEV__NONE_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = MySm_StateId_OM__BEV__NONE;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for OM__BEV__TEA
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state OM__BEV__WATER
////////////////////////////////////////////////////////////////////////////////

static void OM__BEV__WATER_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = OM__BEV__WATER_exit;
    self->current_event_handlers[MySm_EventId_EV1] = OM__BEV__WATER_ev1;
}

static void OM__BEV__WATER_exit(MySm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = OM__BEVERAGE_exit;
    self->current_event_handlers[MySm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void OM__BEV__WATER_ev1(MySm* self)
{
    // No ancestor state handles `EV1` event.
    
    // OM__BEV__WATER behavior
    // uml: EV1 TransitionTo(OM__BEV__TEA)
    {
        // Step 1: Exit states until we reach `OM__BEVERAGE` state (Least Common Ancestor for transition).
        OM__BEV__WATER_exit(self);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `OM__BEV__TEA`.
        OM__BEV__TEA_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = MySm_StateId_OM__BEV__TEA;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for OM__BEV__WATER
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state OM__DESERT
////////////////////////////////////////////////////////////////////////////////

static void OM__DESERT_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = OM__DESERT_exit;
    self->current_event_handlers[MySm_EventId_EV3] = OM__DESERT_ev3;
}

static void OM__DESERT_exit(MySm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ORDER_MENU_exit;
    self->current_event_handlers[MySm_EventId_EV3] = ORDER_MENU_ev3;  // the next ancestor that handles this event is ORDER_MENU
}

static void OM__DESERT_ev3(MySm* self)
{
    // Setup handler for next ancestor that listens to `EV3` event.
    self->ancestor_event_handler = ORDER_MENU_ev3;
    
    // OM__DESERT behavior
    // uml: EV3 TransitionTo(OM__FOOD)
    {
        // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, ORDER_MENU_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `OM__FOOD`.
        OM__FOOD_enter(self);
        
        // Finish transition by calling pseudo state transition function.
        OM__FOOD_InitialState_transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for OM__DESERT
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state DSRT__CAKE
////////////////////////////////////////////////////////////////////////////////

static void DSRT__CAKE_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = DSRT__CAKE_exit;
}

static void DSRT__CAKE_exit(MySm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = OM__DESERT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state OM__FOOD
////////////////////////////////////////////////////////////////////////////////

static void OM__FOOD_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = OM__FOOD_exit;
    self->current_event_handlers[MySm_EventId_EV2] = OM__FOOD_ev2;
    self->current_event_handlers[MySm_EventId_EV3] = OM__FOOD_ev3;
}

static void OM__FOOD_exit(MySm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ORDER_MENU_exit;
    self->current_event_handlers[MySm_EventId_EV2] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[MySm_EventId_EV3] = ORDER_MENU_ev3;  // the next ancestor that handles this event is ORDER_MENU
}

static void OM__FOOD_ev2(MySm* self)
{
    // No ancestor state handles `EV2` event.
    
    // OM__FOOD behavior
    // uml: EV2 TransitionTo(OM__BEVERAGE)
    {
        // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, ORDER_MENU_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `OM__BEVERAGE`.
        OM__BEVERAGE_enter(self);
        
        // Finish transition by calling pseudo state transition function.
        OM__BEVERAGE_InitialState_transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for OM__FOOD
}

static void OM__FOOD_ev3(MySm* self)
{
    // Setup handler for next ancestor that listens to `EV3` event.
    self->ancestor_event_handler = ORDER_MENU_ev3;
    
    // OM__FOOD behavior
    // uml: EV3 TransitionTo(OM__DESERT)
    {
        // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, ORDER_MENU_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `OM__DESERT`.
        OM__DESERT_enter(self);
        
        // OM__DESERT.InitialState behavior
        // uml: TransitionTo(DSRT__CAKE)
        {
            // Step 1: Exit states until we reach `OM__DESERT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `DSRT__CAKE`.
            DSRT__CAKE_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = MySm_StateId_DSRT__CAKE;
            self->ancestor_event_handler = NULL;
            return;
        } // end of behavior for OM__DESERT.InitialState
    } // end of behavior for OM__FOOD
}

static void OM__FOOD_InitialState_transition(MySm* self)
{
    // OM__FOOD.InitialState behavior
    // uml: TransitionTo(OM__FOOD__NONE)
    {
        // Step 1: Exit states until we reach `OM__FOOD` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `OM__FOOD__NONE`.
        OM__FOOD__NONE_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = MySm_StateId_OM__FOOD__NONE;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for OM__FOOD.InitialState
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state OM__FOOD__NONE
////////////////////////////////////////////////////////////////////////////////

static void OM__FOOD__NONE_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = OM__FOOD__NONE_exit;
    self->current_event_handlers[MySm_EventId_EV1] = OM__FOOD__NONE_ev1;
}

static void OM__FOOD__NONE_exit(MySm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = OM__FOOD_exit;
    self->current_event_handlers[MySm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void OM__FOOD__NONE_ev1(MySm* self)
{
    // No ancestor state handles `EV1` event.
    
    // OM__FOOD__NONE behavior
    // uml: EV1 TransitionTo(OM__FOOD__POTATO)
    {
        // Step 1: Exit states until we reach `OM__FOOD` state (Least Common Ancestor for transition).
        OM__FOOD__NONE_exit(self);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `OM__FOOD__POTATO`.
        OM__FOOD__POTATO_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = MySm_StateId_OM__FOOD__POTATO;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for OM__FOOD__NONE
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state OM__FOOD__POTATO
////////////////////////////////////////////////////////////////////////////////

static void OM__FOOD__POTATO_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = OM__FOOD__POTATO_exit;
    self->current_event_handlers[MySm_EventId_EV1] = OM__FOOD__POTATO_ev1;
}

static void OM__FOOD__POTATO_exit(MySm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = OM__FOOD_exit;
    self->current_event_handlers[MySm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void OM__FOOD__POTATO_ev1(MySm* self)
{
    // No ancestor state handles `EV1` event.
    
    // OM__FOOD__POTATO behavior
    // uml: EV1 TransitionTo(OM__FOOD__SUSHI)
    {
        // Step 1: Exit states until we reach `OM__FOOD` state (Least Common Ancestor for transition).
        OM__FOOD__POTATO_exit(self);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `OM__FOOD__SUSHI`.
        OM__FOOD__SUSHI_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = MySm_StateId_OM__FOOD__SUSHI;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for OM__FOOD__POTATO
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state OM__FOOD__SUSHI
////////////////////////////////////////////////////////////////////////////////

static void OM__FOOD__SUSHI_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = OM__FOOD__SUSHI_exit;
    self->current_event_handlers[MySm_EventId_EV1] = OM__FOOD__SUSHI_ev1;
}

static void OM__FOOD__SUSHI_exit(MySm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = OM__FOOD_exit;
    self->current_event_handlers[MySm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void OM__FOOD__SUSHI_ev1(MySm* self)
{
    // No ancestor state handles `EV1` event.
    
    // OM__FOOD__SUSHI behavior
    // uml: EV1 TransitionTo(OM__FOOD__NONE)
    {
        // Step 1: Exit states until we reach `OM__FOOD` state (Least Common Ancestor for transition).
        OM__FOOD__SUSHI_exit(self);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `OM__FOOD__NONE`.
        OM__FOOD__NONE_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = MySm_StateId_OM__FOOD__NONE;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for OM__FOOD__SUSHI
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state WAITING
////////////////////////////////////////////////////////////////////////////////

static void WAITING_enter(MySm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = WAITING_exit;
    self->current_event_handlers[MySm_EventId_EV3] = WAITING_ev3;
}

static void WAITING_exit(MySm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
    self->current_event_handlers[MySm_EventId_EV3] = NULL;  // no ancestor listens to this event
}

static void WAITING_ev3(MySm* self)
{
    // No ancestor state handles `EV3` event.
    
    // WAITING behavior
    // uml: EV3 TransitionTo(ORDER_MENU)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        WAITING_exit(self);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ORDER_MENU`.
        ORDER_MENU_enter(self);
        
        // ORDER_MENU.InitialState behavior
        // uml: TransitionTo(OM__BEVERAGE)
        {
            // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `OM__BEVERAGE`.
            OM__BEVERAGE_enter(self);
            
            // Finish transition by calling pseudo state transition function.
            OM__BEVERAGE_InitialState_transition(self);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ORDER_MENU.InitialState
    } // end of behavior for WAITING
}


