// Autogenerated with StateSmith 0.9.6-alpha.
// Algorithm: Balanced1. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

#include "WaterCannonSm.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(WaterCannonSm* sm, WaterCannonSm_Func desired_state_exit_handler);

static void ROOT_enter(WaterCannonSm* sm);

static void ROOT_exit(WaterCannonSm* sm);

static void AUTO_GROUP_enter(WaterCannonSm* sm);

static void AUTO_GROUP_exit(WaterCannonSm* sm);

static void AUTO_GROUP_back_press(WaterCannonSm* sm);

static void AUTO_enter(WaterCannonSm* sm);

static void AUTO_exit(WaterCannonSm* sm);

static void AUTO_do(WaterCannonSm* sm);

static void CALIBRATION_NAG_enter(WaterCannonSm* sm);

static void CALIBRATION_NAG_exit(WaterCannonSm* sm);

static void CALIBRATION_NAG_ok_press(WaterCannonSm* sm);

static void CAL_GROUP_enter(WaterCannonSm* sm);

static void CAL_GROUP_exit(WaterCannonSm* sm);

static void CAL_GROUP_back_press(WaterCannonSm* sm);

static void CAL_GROUP_InitialState_transition(WaterCannonSm* sm);

static void CAL_GROUP_ExitPoint_done__transition(WaterCannonSm* sm);

static void CANCELLABLE_enter(WaterCannonSm* sm);

static void CANCELLABLE_exit(WaterCannonSm* sm);

static void CANCELLABLE_back_press(WaterCannonSm* sm);

static void LOWER_enter(WaterCannonSm* sm);

static void LOWER_exit(WaterCannonSm* sm);

static void LOWER_ok_press(WaterCannonSm* sm);

static void RAISE_enter(WaterCannonSm* sm);

static void RAISE_exit(WaterCannonSm* sm);

static void RAISE_ok_press(WaterCannonSm* sm);

static void CANCELLED_enter(WaterCannonSm* sm);

static void CANCELLED_exit(WaterCannonSm* sm);

static void CANCELLED_ok_press(WaterCannonSm* sm);

static void CONFIRMATION_enter(WaterCannonSm* sm);

static void CONFIRMATION_exit(WaterCannonSm* sm);

static void CONFIRMATION_ok_press(WaterCannonSm* sm);

static void HOME_enter(WaterCannonSm* sm);

static void HOME_exit(WaterCannonSm* sm);

static void HOME_auto_press(WaterCannonSm* sm);

static void HOME_cal_press(WaterCannonSm* sm);

static void SPLASH_SCREEN_enter(WaterCannonSm* sm);

static void SPLASH_SCREEN_exit(WaterCannonSm* sm);

static void SPLASH_SCREEN_ok_press(WaterCannonSm* sm);


// State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
void WaterCannonSm_ctor(WaterCannonSm* sm)
{
    memset(sm, 0, sizeof(*sm));
}

// Starts the state machine. Must be called before dispatching events. Not thread safe.
void WaterCannonSm_start(WaterCannonSm* sm)
{
    ROOT_enter(sm);
    // ROOT behavior
    // uml: TransitionTo(ROOT.<InitialState>)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
        // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<InitialState> behavior
        // uml: TransitionTo(SPLASH_SCREEN)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `SPLASH_SCREEN`.
            SPLASH_SCREEN_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = WaterCannonSm_StateId_SPLASH_SCREEN;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for ROOT.<InitialState>
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
void WaterCannonSm_dispatch_event(WaterCannonSm* sm, WaterCannonSm_EventId event_id)
{
    WaterCannonSm_Func behavior_func = sm->current_event_handlers[event_id];
    
    while (behavior_func != NULL)
    {
        sm->ancestor_event_handler = NULL;
        behavior_func(sm);
        behavior_func = sm->ancestor_event_handler;
    }
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(WaterCannonSm* sm, WaterCannonSm_Func desired_state_exit_handler)
{
    while (sm->current_state_exit_handler != desired_state_exit_handler)
    {
        sm->current_state_exit_handler(sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = ROOT_exit;
}

static void ROOT_exit(WaterCannonSm* sm)
{
    // State machine root is a special case. It cannot be exited. Mark as unused.
    (void)sm;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state AUTO_GROUP
////////////////////////////////////////////////////////////////////////////////

static void AUTO_GROUP_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = AUTO_GROUP_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_BACK_PRESS] = AUTO_GROUP_back_press;
}

static void AUTO_GROUP_exit(WaterCannonSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_BACK_PRESS] = NULL;  // no ancestor listens to this event
}

static void AUTO_GROUP_back_press(WaterCannonSm* sm)
{
    // No ancestor state handles `back_press` event.
    
    // AUTO_GROUP behavior
    // uml: BACK_PRESS TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = WaterCannonSm_StateId_HOME;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for AUTO_GROUP
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state AUTO
////////////////////////////////////////////////////////////////////////////////

static void AUTO_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = AUTO_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_DO] = AUTO_do;
    
    // AUTO behavior
    // uml: enter / { Screens_show_auto(); }
    {
        // Step 1: execute action `Screens_show_auto();`
        Screens_show_auto();
    } // end of behavior for AUTO
}

static void AUTO_exit(WaterCannonSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = AUTO_GROUP_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void AUTO_do(WaterCannonSm* sm)
{
    // No ancestor state handles `do` event.
    
    // AUTO behavior
    // uml: do / { /* do auto stuff */ }
    {
        // Step 1: execute action `/* do auto stuff */`
        /* do auto stuff */
        
        // Step 2: determine if ancestor gets to handle event next.
        // Don't consume special `do` event.
    } // end of behavior for AUTO
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATION_NAG
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATION_NAG_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = CALIBRATION_NAG_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = CALIBRATION_NAG_ok_press;
    
    // CALIBRATION_NAG behavior
    // uml: enter / { Screens_show_cal_required();\n// make an annoying sound }
    {
        // Step 1: execute action `Screens_show_cal_required();\n// make an annoying sound`
        Screens_show_cal_required();
        // make an annoying sound<EOF>
    } // end of behavior for CALIBRATION_NAG
}

static void CALIBRATION_NAG_exit(WaterCannonSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = AUTO_GROUP_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
}

static void CALIBRATION_NAG_ok_press(WaterCannonSm* sm)
{
    // No ancestor state handles `ok_press` event.
    
    // CALIBRATION_NAG behavior
    // uml: OK_PRESS TransitionTo(AUTO_GROUP.<ExitPoint>(cal))
    {
        // Step 1: Exit states until we reach `AUTO_GROUP` state (Least Common Ancestor for transition).
        CALIBRATION_NAG_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `AUTO_GROUP.<ExitPoint>(cal)`.
        // AUTO_GROUP.<ExitPoint>(cal) is a pseudo state and cannot have an `enter` trigger.
        
        // AUTO_GROUP.<ExitPoint>(cal) behavior
        // uml: TransitionTo(CAL_GROUP)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            AUTO_GROUP_exit(sm);
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `CAL_GROUP`.
            CAL_GROUP_enter(sm);
            
            // Finish transition by calling pseudo state transition function.
            CAL_GROUP_InitialState_transition(sm);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for AUTO_GROUP.<ExitPoint>(cal)
    } // end of behavior for CALIBRATION_NAG
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CAL_GROUP
////////////////////////////////////////////////////////////////////////////////

static void CAL_GROUP_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = CAL_GROUP_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_BACK_PRESS] = CAL_GROUP_back_press;
}

static void CAL_GROUP_exit(WaterCannonSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_BACK_PRESS] = NULL;  // no ancestor listens to this event
}

static void CAL_GROUP_back_press(WaterCannonSm* sm)
{
    // No ancestor state handles `back_press` event.
    
    // CAL_GROUP behavior
    // uml: BACK_PRESS TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = WaterCannonSm_StateId_HOME;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for CAL_GROUP
}

static void CAL_GROUP_InitialState_transition(WaterCannonSm* sm)
{
    // CAL_GROUP.<InitialState> behavior
    // uml: TransitionTo(LOWER)
    {
        // Step 1: Exit states until we reach `CAL_GROUP` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `LOWER`.
        CANCELLABLE_enter(sm);
        LOWER_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = WaterCannonSm_StateId_LOWER;
        sm->ancestor_event_handler = NULL;
        return;
    } // end of behavior for CAL_GROUP.<InitialState>
}

static void CAL_GROUP_ExitPoint_done__transition(WaterCannonSm* sm)
{
    // CAL_GROUP.<ExitPoint>(done) behavior
    // uml: TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        CAL_GROUP_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = WaterCannonSm_StateId_HOME;
        sm->ancestor_event_handler = NULL;
        return;
    } // end of behavior for CAL_GROUP.<ExitPoint>(done)
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CANCELLABLE
////////////////////////////////////////////////////////////////////////////////

static void CANCELLABLE_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = CANCELLABLE_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_BACK_PRESS] = CANCELLABLE_back_press;
}

static void CANCELLABLE_exit(WaterCannonSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = CAL_GROUP_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_BACK_PRESS] = CAL_GROUP_back_press;  // the next ancestor that handles this event is CAL_GROUP
}

static void CANCELLABLE_back_press(WaterCannonSm* sm)
{
    // Setup handler for next ancestor that listens to `back_press` event.
    sm->ancestor_event_handler = CAL_GROUP_back_press;
    
    // CANCELLABLE behavior
    // uml: BACK_PRESS TransitionTo(CANCELLED)
    {
        // Step 1: Exit states until we reach `CAL_GROUP` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, CAL_GROUP_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CANCELLED`.
        CANCELLED_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = WaterCannonSm_StateId_CANCELLED;
        sm->ancestor_event_handler = NULL;
        return;
    } // end of behavior for CANCELLABLE
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state LOWER
////////////////////////////////////////////////////////////////////////////////

static void LOWER_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = LOWER_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = LOWER_ok_press;
    
    // LOWER behavior
    // uml: enter / { Screens_show_cal_lower(); }
    {
        // Step 1: execute action `Screens_show_cal_lower();`
        Screens_show_cal_lower();
    } // end of behavior for LOWER
}

static void LOWER_exit(WaterCannonSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = CANCELLABLE_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
}

static void LOWER_ok_press(WaterCannonSm* sm)
{
    // No ancestor state handles `ok_press` event.
    
    // LOWER behavior
    // uml: OK_PRESS / { capture_lowered_position(); } TransitionTo(RAISE)
    {
        // Step 1: Exit states until we reach `CANCELLABLE` state (Least Common Ancestor for transition).
        LOWER_exit(sm);
        
        // Step 2: Transition action: `capture_lowered_position();`.
        WaterCannon_capture_lowered_position();
        
        // Step 3: Enter/move towards transition target `RAISE`.
        RAISE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = WaterCannonSm_StateId_RAISE;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for LOWER
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state RAISE
////////////////////////////////////////////////////////////////////////////////

static void RAISE_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = RAISE_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = RAISE_ok_press;
    
    // RAISE behavior
    // uml: enter / { Screens_show_cal_raise(); }
    {
        // Step 1: execute action `Screens_show_cal_raise();`
        Screens_show_cal_raise();
    } // end of behavior for RAISE
}

static void RAISE_exit(WaterCannonSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = CANCELLABLE_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
}

static void RAISE_ok_press(WaterCannonSm* sm)
{
    // No ancestor state handles `ok_press` event.
    
    // RAISE behavior
    // uml: OK_PRESS / { capture_raised_position(); } TransitionTo(CONFIRMATION)
    {
        // Step 1: Exit states until we reach `CAL_GROUP` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, CAL_GROUP_exit);
        
        // Step 2: Transition action: `capture_raised_position();`.
        WaterCannon_capture_raised_position();
        
        // Step 3: Enter/move towards transition target `CONFIRMATION`.
        CONFIRMATION_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = WaterCannonSm_StateId_CONFIRMATION;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for RAISE
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CANCELLED
////////////////////////////////////////////////////////////////////////////////

static void CANCELLED_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = CANCELLED_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = CANCELLED_ok_press;
    
    // CANCELLED behavior
    // uml: enter / { Screens_show_cal_cancelled(); }
    {
        // Step 1: execute action `Screens_show_cal_cancelled();`
        Screens_show_cal_cancelled();
    } // end of behavior for CANCELLED
}

static void CANCELLED_exit(WaterCannonSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = CAL_GROUP_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
}

static void CANCELLED_ok_press(WaterCannonSm* sm)
{
    // No ancestor state handles `ok_press` event.
    
    // CANCELLED behavior
    // uml: OK_PRESS TransitionTo(CAL_GROUP.<ExitPoint>(done))
    {
        // Step 1: Exit states until we reach `CAL_GROUP` state (Least Common Ancestor for transition).
        CANCELLED_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CAL_GROUP.<ExitPoint>(done)`.
        // CAL_GROUP.<ExitPoint>(done) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        CAL_GROUP_ExitPoint_done__transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for CANCELLED
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CONFIRMATION
////////////////////////////////////////////////////////////////////////////////

static void CONFIRMATION_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = CONFIRMATION_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = CONFIRMATION_ok_press;
    
    // CONFIRMATION behavior
    // uml: enter / { Screens_show_cal_done(); }
    {
        // Step 1: execute action `Screens_show_cal_done();`
        Screens_show_cal_done();
    } // end of behavior for CONFIRMATION
}

static void CONFIRMATION_exit(WaterCannonSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = CAL_GROUP_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
}

static void CONFIRMATION_ok_press(WaterCannonSm* sm)
{
    // No ancestor state handles `ok_press` event.
    
    // CONFIRMATION behavior
    // uml: OK_PRESS TransitionTo(CAL_GROUP.<ExitPoint>(done))
    {
        // Step 1: Exit states until we reach `CAL_GROUP` state (Least Common Ancestor for transition).
        CONFIRMATION_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CAL_GROUP.<ExitPoint>(done)`.
        // CAL_GROUP.<ExitPoint>(done) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        CAL_GROUP_ExitPoint_done__transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for CONFIRMATION
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state HOME
////////////////////////////////////////////////////////////////////////////////

static void HOME_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = HOME_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_AUTO_PRESS] = HOME_auto_press;
    sm->current_event_handlers[WaterCannonSm_EventId_CAL_PRESS] = HOME_cal_press;
    
    // HOME behavior
    // uml: enter / { Screens_show_home(); }
    {
        // Step 1: execute action `Screens_show_home();`
        Screens_show_home();
    } // end of behavior for HOME
}

static void HOME_exit(WaterCannonSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_AUTO_PRESS] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[WaterCannonSm_EventId_CAL_PRESS] = NULL;  // no ancestor listens to this event
}

static void HOME_auto_press(WaterCannonSm* sm)
{
    // No ancestor state handles `auto_press` event.
    
    // HOME behavior
    // uml: AUTO_PRESS TransitionTo(AUTO_GROUP)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        HOME_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `AUTO_GROUP`.
        AUTO_GROUP_enter(sm);
        
        // AUTO_GROUP.<InitialState> behavior
        // uml: TransitionTo(AUTO_GROUP.<ChoicePoint>(auto_check))
        {
            // Step 1: Exit states until we reach `AUTO_GROUP` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `AUTO_GROUP.<ChoicePoint>(auto_check)`.
            // AUTO_GROUP.<ChoicePoint>(auto_check) is a pseudo state and cannot have an `enter` trigger.
            
            // AUTO_GROUP.<ChoicePoint>(auto_check) behavior
            // uml: TransitionTo(CALIBRATION_NAG)
            {
                // Step 1: Exit states until we reach `AUTO_GROUP` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `CALIBRATION_NAG`.
                CALIBRATION_NAG_enter(sm);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                sm->state_id = WaterCannonSm_StateId_CALIBRATION_NAG;
                // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
                return;
            } // end of behavior for AUTO_GROUP.<ChoicePoint>(auto_check)
            
            // AUTO_GROUP.<ChoicePoint>(auto_check) behavior
            // uml: [is_calibrated] TransitionTo(AUTO)
            if (WaterCannon_is_calibrated())
            {
                // Step 1: Exit states until we reach `AUTO_GROUP` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `AUTO`.
                AUTO_enter(sm);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                sm->state_id = WaterCannonSm_StateId_AUTO;
                // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
                return;
            } // end of behavior for AUTO_GROUP.<ChoicePoint>(auto_check)
        } // end of behavior for AUTO_GROUP.<InitialState>
    } // end of behavior for HOME
}

static void HOME_cal_press(WaterCannonSm* sm)
{
    // No ancestor state handles `cal_press` event.
    
    // HOME behavior
    // uml: CAL_PRESS TransitionTo(CAL_GROUP)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        HOME_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CAL_GROUP`.
        CAL_GROUP_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        CAL_GROUP_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for HOME
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SPLASH_SCREEN
////////////////////////////////////////////////////////////////////////////////

static void SPLASH_SCREEN_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = SPLASH_SCREEN_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = SPLASH_SCREEN_ok_press;
    
    // SPLASH_SCREEN behavior
    // uml: enter / { Screens_show_splash(); }
    {
        // Step 1: execute action `Screens_show_splash();`
        Screens_show_splash();
    } // end of behavior for SPLASH_SCREEN
}

static void SPLASH_SCREEN_exit(WaterCannonSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
}

static void SPLASH_SCREEN_ok_press(WaterCannonSm* sm)
{
    // No ancestor state handles `ok_press` event.
    
    // SPLASH_SCREEN behavior
    // uml: OK_PRESS TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        SPLASH_SCREEN_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = WaterCannonSm_StateId_HOME;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for SPLASH_SCREEN
}

// Thread safe.
char const * WaterCannonSm_state_id_to_string(WaterCannonSm_StateId id)
{
    switch (id)
    {
        case WaterCannonSm_StateId_ROOT: return "ROOT";
        case WaterCannonSm_StateId_AUTO_GROUP: return "AUTO_GROUP";
        case WaterCannonSm_StateId_AUTO: return "AUTO";
        case WaterCannonSm_StateId_CALIBRATION_NAG: return "CALIBRATION_NAG";
        case WaterCannonSm_StateId_CAL_GROUP: return "CAL_GROUP";
        case WaterCannonSm_StateId_CANCELLABLE: return "CANCELLABLE";
        case WaterCannonSm_StateId_LOWER: return "LOWER";
        case WaterCannonSm_StateId_RAISE: return "RAISE";
        case WaterCannonSm_StateId_CANCELLED: return "CANCELLED";
        case WaterCannonSm_StateId_CONFIRMATION: return "CONFIRMATION";
        case WaterCannonSm_StateId_HOME: return "HOME";
        case WaterCannonSm_StateId_SPLASH_SCREEN: return "SPLASH_SCREEN";
        default: return "?";
    }
}

// Thread safe.
char const * WaterCannonSm_event_id_to_string(WaterCannonSm_EventId id)
{
    switch (id)
    {
        case WaterCannonSm_EventId_AUTO_PRESS: return "AUTO_PRESS";
        case WaterCannonSm_EventId_BACK_PRESS: return "BACK_PRESS";
        case WaterCannonSm_EventId_CAL_PRESS: return "CAL_PRESS";
        case WaterCannonSm_EventId_DO: return "DO";
        case WaterCannonSm_EventId_OK_PRESS: return "OK_PRESS";
        default: return "?";
    }
}
