// Autogenerated with StateSmith 0.9.6-alpha.
// Algorithm: Balanced1. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

#include "WaterCannonSm.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(WaterCannonSm* sm, WaterCannonSm_Func desired_state_exit_handler);

static void ROOT_enter(WaterCannonSm* sm);

static void ROOT_exit(WaterCannonSm* sm);

static void AUTO_GROUP_enter(WaterCannonSm* sm);

static void AUTO_GROUP_exit(WaterCannonSm* sm);

static void AUTO_GROUP_back_press(WaterCannonSm* sm);

static void AUTO_enter(WaterCannonSm* sm);

static void AUTO_exit(WaterCannonSm* sm);

static void AUTO_do(WaterCannonSm* sm);

static void CALIBRATION_NAG_enter(WaterCannonSm* sm);

static void CALIBRATION_NAG_exit(WaterCannonSm* sm);

static void CALIBRATION_NAG_ok_press(WaterCannonSm* sm);

static void CAL_GROUP_enter(WaterCannonSm* sm);

static void CAL_GROUP_exit(WaterCannonSm* sm);

static void CAL_GROUP_back_press(WaterCannonSm* sm);

static void CAL_GROUP_InitialState_transition(WaterCannonSm* sm);

static void CONFIRMATION_enter(WaterCannonSm* sm);

static void CONFIRMATION_exit(WaterCannonSm* sm);

static void CONFIRMATION_ok_press(WaterCannonSm* sm);

static void LOWER_enter(WaterCannonSm* sm);

static void LOWER_exit(WaterCannonSm* sm);

static void LOWER_ok_press(WaterCannonSm* sm);

static void RAISE_enter(WaterCannonSm* sm);

static void RAISE_exit(WaterCannonSm* sm);

static void RAISE_ok_press(WaterCannonSm* sm);

static void HOME_enter(WaterCannonSm* sm);

static void HOME_exit(WaterCannonSm* sm);

static void HOME_auto(WaterCannonSm* sm);

static void HOME_cal_press(WaterCannonSm* sm);

static void SPLASH_SCREEN_enter(WaterCannonSm* sm);

static void SPLASH_SCREEN_exit(WaterCannonSm* sm);

static void SPLASH_SCREEN_ok_press(WaterCannonSm* sm);


// State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
void WaterCannonSm_ctor(WaterCannonSm* sm)
{
    memset(sm, 0, sizeof(*sm));
}

// Starts the state machine. Must be called before dispatching events. Not thread safe.
void WaterCannonSm_start(WaterCannonSm* sm)
{
    ROOT_enter(sm);
    // ROOT behavior
    // uml: TransitionTo(ROOT.<InitialState>)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
        // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<InitialState> behavior
        // uml: TransitionTo(SPLASH_SCREEN)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `SPLASH_SCREEN`.
            SPLASH_SCREEN_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = WaterCannonSm_StateId_SPLASH_SCREEN;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for ROOT.<InitialState>
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
void WaterCannonSm_dispatch_event(WaterCannonSm* sm, WaterCannonSm_EventId event_id)
{
    WaterCannonSm_Func behavior_func = sm->current_event_handlers[event_id];
    
    while (behavior_func != NULL)
    {
        sm->ancestor_event_handler = NULL;
        behavior_func(sm);
        behavior_func = sm->ancestor_event_handler;
    }
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(WaterCannonSm* sm, WaterCannonSm_Func desired_state_exit_handler)
{
    while (sm->current_state_exit_handler != desired_state_exit_handler)
    {
        sm->current_state_exit_handler(sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = ROOT_exit;
}

static void ROOT_exit(WaterCannonSm* sm)
{
    // State machine root is a special case. It cannot be exited. Mark as unused.
    (void)sm;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state AUTO_GROUP
////////////////////////////////////////////////////////////////////////////////

static void AUTO_GROUP_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = AUTO_GROUP_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_BACK_PRESS] = AUTO_GROUP_back_press;
}

static void AUTO_GROUP_exit(WaterCannonSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_BACK_PRESS] = NULL;  // no ancestor listens to this event
}

static void AUTO_GROUP_back_press(WaterCannonSm* sm)
{
    // No ancestor state handles `back_press` event.
    
    // AUTO_GROUP behavior
    // uml: BACK_PRESS TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = WaterCannonSm_StateId_HOME;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for AUTO_GROUP
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state AUTO
////////////////////////////////////////////////////////////////////////////////

static void AUTO_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = AUTO_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_DO] = AUTO_do;
    
    // AUTO behavior
    // uml: enter / { show_auto_screen(); }
    {
        // Step 1: execute action `show_auto_screen();`
        show_auto_screen();
    } // end of behavior for AUTO
}

static void AUTO_exit(WaterCannonSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = AUTO_GROUP_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void AUTO_do(WaterCannonSm* sm)
{
    // No ancestor state handles `do` event.
    
    // AUTO behavior
    // uml: do / { auto_iteration(); }
    {
        // Step 1: execute action `auto_iteration();`
        auto_iteration();
        
        // Step 2: determine if ancestor gets to handle event next.
        // Don't consume special `do` event.
    } // end of behavior for AUTO
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATION_NAG
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATION_NAG_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = CALIBRATION_NAG_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = CALIBRATION_NAG_ok_press;
    
    // CALIBRATION_NAG behavior
    // uml: enter / { show_cal_required_screen();\nt1_reset();\nbeep(); }
    {
        // Step 1: execute action `show_cal_required_screen();\nt1_reset();\nbeep();`
        show_cal_required_screen();
        t1_reset();
        beep();
    } // end of behavior for CALIBRATION_NAG
}

static void CALIBRATION_NAG_exit(WaterCannonSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = AUTO_GROUP_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
}

static void CALIBRATION_NAG_ok_press(WaterCannonSm* sm)
{
    // No ancestor state handles `ok_press` event.
    
    // CALIBRATION_NAG behavior
    // uml: OK_PRESS TransitionTo(AUTO_GROUP.<ExitPoint>(cal))
    {
        // Step 1: Exit states until we reach `AUTO_GROUP` state (Least Common Ancestor for transition).
        CALIBRATION_NAG_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `AUTO_GROUP.<ExitPoint>(cal)`.
        // AUTO_GROUP.<ExitPoint>(cal) is a pseudo state and cannot have an `enter` trigger.
        
        // AUTO_GROUP.<ExitPoint>(cal) behavior
        // uml: TransitionTo(CAL_GROUP)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            AUTO_GROUP_exit(sm);
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `CAL_GROUP`.
            CAL_GROUP_enter(sm);
            
            // Finish transition by calling pseudo state transition function.
            CAL_GROUP_InitialState_transition(sm);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for AUTO_GROUP.<ExitPoint>(cal)
    } // end of behavior for CALIBRATION_NAG
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CAL_GROUP
////////////////////////////////////////////////////////////////////////////////

static void CAL_GROUP_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = CAL_GROUP_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_BACK_PRESS] = CAL_GROUP_back_press;
}

static void CAL_GROUP_exit(WaterCannonSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_BACK_PRESS] = NULL;  // no ancestor listens to this event
}

static void CAL_GROUP_back_press(WaterCannonSm* sm)
{
    // No ancestor state handles `back_press` event.
    
    // CAL_GROUP behavior
    // uml: BACK_PRESS TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = WaterCannonSm_StateId_HOME;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for CAL_GROUP
}

static void CAL_GROUP_InitialState_transition(WaterCannonSm* sm)
{
    // CAL_GROUP.<InitialState> behavior
    // uml: TransitionTo(LOWER)
    {
        // Step 1: Exit states until we reach `CAL_GROUP` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `LOWER`.
        LOWER_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = WaterCannonSm_StateId_LOWER;
        sm->ancestor_event_handler = NULL;
        return;
    } // end of behavior for CAL_GROUP.<InitialState>
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CONFIRMATION
////////////////////////////////////////////////////////////////////////////////

static void CONFIRMATION_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = CONFIRMATION_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = CONFIRMATION_ok_press;
    
    // CONFIRMATION behavior
    // uml: enter / { show_cal_done_screen(); }
    {
        // Step 1: execute action `show_cal_done_screen();`
        show_cal_done_screen();
    } // end of behavior for CONFIRMATION
}

static void CONFIRMATION_exit(WaterCannonSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = CAL_GROUP_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
}

static void CONFIRMATION_ok_press(WaterCannonSm* sm)
{
    // No ancestor state handles `ok_press` event.
    
    // CONFIRMATION behavior
    // uml: OK_PRESS TransitionTo(CAL_GROUP.<ExitPoint>(done))
    {
        // Step 1: Exit states until we reach `CAL_GROUP` state (Least Common Ancestor for transition).
        CONFIRMATION_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CAL_GROUP.<ExitPoint>(done)`.
        // CAL_GROUP.<ExitPoint>(done) is a pseudo state and cannot have an `enter` trigger.
        
        // CAL_GROUP.<ExitPoint>(done) behavior
        // uml: TransitionTo(HOME)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            CAL_GROUP_exit(sm);
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `HOME`.
            HOME_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = WaterCannonSm_StateId_HOME;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for CAL_GROUP.<ExitPoint>(done)
    } // end of behavior for CONFIRMATION
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state LOWER
////////////////////////////////////////////////////////////////////////////////

static void LOWER_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = LOWER_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = LOWER_ok_press;
    
    // LOWER behavior
    // uml: enter / { show_cal_lower_screen(); }
    {
        // Step 1: execute action `show_cal_lower_screen();`
        show_cal_lower_screen();
    } // end of behavior for LOWER
}

static void LOWER_exit(WaterCannonSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = CAL_GROUP_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
}

static void LOWER_ok_press(WaterCannonSm* sm)
{
    // No ancestor state handles `ok_press` event.
    
    // LOWER behavior
    // uml: OK_PRESS / { capture_lower_position(); } TransitionTo(RAISE)
    {
        // Step 1: Exit states until we reach `CAL_GROUP` state (Least Common Ancestor for transition).
        LOWER_exit(sm);
        
        // Step 2: Transition action: `capture_lower_position();`.
        capture_lower_position();
        
        // Step 3: Enter/move towards transition target `RAISE`.
        RAISE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = WaterCannonSm_StateId_RAISE;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for LOWER
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state RAISE
////////////////////////////////////////////////////////////////////////////////

static void RAISE_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = RAISE_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = RAISE_ok_press;
    
    // RAISE behavior
    // uml: enter / { show_cal_raise_screen(); }
    {
        // Step 1: execute action `show_cal_raise_screen();`
        show_cal_raise_screen();
    } // end of behavior for RAISE
}

static void RAISE_exit(WaterCannonSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = CAL_GROUP_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
}

static void RAISE_ok_press(WaterCannonSm* sm)
{
    // No ancestor state handles `ok_press` event.
    
    // RAISE behavior
    // uml: OK_PRESS / { capture_raised_position(); } TransitionTo(CONFIRMATION)
    {
        // Step 1: Exit states until we reach `CAL_GROUP` state (Least Common Ancestor for transition).
        RAISE_exit(sm);
        
        // Step 2: Transition action: `capture_raised_position();`.
        capture_raised_position();
        
        // Step 3: Enter/move towards transition target `CONFIRMATION`.
        CONFIRMATION_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = WaterCannonSm_StateId_CONFIRMATION;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for RAISE
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state HOME
////////////////////////////////////////////////////////////////////////////////

static void HOME_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = HOME_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_AUTO] = HOME_auto;
    sm->current_event_handlers[WaterCannonSm_EventId_CAL_PRESS] = HOME_cal_press;
    
    // HOME behavior
    // uml: enter / { show_home_screen(); }
    {
        // Step 1: execute action `show_home_screen();`
        show_home_screen();
    } // end of behavior for HOME
}

static void HOME_exit(WaterCannonSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_AUTO] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[WaterCannonSm_EventId_CAL_PRESS] = NULL;  // no ancestor listens to this event
}

static void HOME_auto(WaterCannonSm* sm)
{
    // No ancestor state handles `auto` event.
    
    // HOME behavior
    // uml: AUTO TransitionTo(AUTO_GROUP)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        HOME_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `AUTO_GROUP`.
        AUTO_GROUP_enter(sm);
        
        // AUTO_GROUP.<InitialState> behavior
        // uml: TransitionTo(AUTO_GROUP.<ChoicePoint>(auto_check))
        {
            // Step 1: Exit states until we reach `AUTO_GROUP` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `AUTO_GROUP.<ChoicePoint>(auto_check)`.
            // AUTO_GROUP.<ChoicePoint>(auto_check) is a pseudo state and cannot have an `enter` trigger.
            
            // AUTO_GROUP.<ChoicePoint>(auto_check) behavior
            // uml: TransitionTo(CALIBRATION_NAG)
            {
                // Step 1: Exit states until we reach `AUTO_GROUP` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `CALIBRATION_NAG`.
                CALIBRATION_NAG_enter(sm);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                sm->state_id = WaterCannonSm_StateId_CALIBRATION_NAG;
                // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
                return;
            } // end of behavior for AUTO_GROUP.<ChoicePoint>(auto_check)
            
            // AUTO_GROUP.<ChoicePoint>(auto_check) behavior
            // uml: [is_calibrated] TransitionTo(AUTO)
            if (is_calibrated)
            {
                // Step 1: Exit states until we reach `AUTO_GROUP` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `AUTO`.
                AUTO_enter(sm);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                sm->state_id = WaterCannonSm_StateId_AUTO;
                // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
                return;
            } // end of behavior for AUTO_GROUP.<ChoicePoint>(auto_check)
        } // end of behavior for AUTO_GROUP.<InitialState>
    } // end of behavior for HOME
}

static void HOME_cal_press(WaterCannonSm* sm)
{
    // No ancestor state handles `cal_press` event.
    
    // HOME behavior
    // uml: CAL_PRESS TransitionTo(CAL_GROUP)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        HOME_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CAL_GROUP`.
        CAL_GROUP_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        CAL_GROUP_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for HOME
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SPLASH_SCREEN
////////////////////////////////////////////////////////////////////////////////

static void SPLASH_SCREEN_enter(WaterCannonSm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = SPLASH_SCREEN_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = SPLASH_SCREEN_ok_press;
    
    // SPLASH_SCREEN behavior
    // uml: enter / { show_splash_screen(); }
    {
        // Step 1: execute action `show_splash_screen();`
        show_splash_screen();
    } // end of behavior for SPLASH_SCREEN
}

static void SPLASH_SCREEN_exit(WaterCannonSm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[WaterCannonSm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
}

static void SPLASH_SCREEN_ok_press(WaterCannonSm* sm)
{
    // No ancestor state handles `ok_press` event.
    
    // SPLASH_SCREEN behavior
    // uml: OK_PRESS TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        SPLASH_SCREEN_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = WaterCannonSm_StateId_HOME;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for SPLASH_SCREEN
}

// Thread safe.
char const * WaterCannonSm_state_id_to_string(WaterCannonSm_StateId id)
{
    switch (id)
    {
        case WaterCannonSm_StateId_ROOT: return "ROOT";
        case WaterCannonSm_StateId_AUTO_GROUP: return "AUTO_GROUP";
        case WaterCannonSm_StateId_AUTO: return "AUTO";
        case WaterCannonSm_StateId_CALIBRATION_NAG: return "CALIBRATION_NAG";
        case WaterCannonSm_StateId_CAL_GROUP: return "CAL_GROUP";
        case WaterCannonSm_StateId_CONFIRMATION: return "CONFIRMATION";
        case WaterCannonSm_StateId_LOWER: return "LOWER";
        case WaterCannonSm_StateId_RAISE: return "RAISE";
        case WaterCannonSm_StateId_HOME: return "HOME";
        case WaterCannonSm_StateId_SPLASH_SCREEN: return "SPLASH_SCREEN";
        default: return "?";
    }
}

// Thread safe.
char const * WaterCannonSm_event_id_to_string(WaterCannonSm_EventId id)
{
    switch (id)
    {
        case WaterCannonSm_EventId_AUTO: return "AUTO";
        case WaterCannonSm_EventId_BACK_PRESS: return "BACK_PRESS";
        case WaterCannonSm_EventId_CAL_PRESS: return "CAL_PRESS";
        case WaterCannonSm_EventId_DO: return "DO";
        case WaterCannonSm_EventId_OK_PRESS: return "OK_PRESS";
        default: return "?";
    }
}
